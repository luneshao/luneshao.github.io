<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端 on Luneshao</title>
    <link>https://luneshao.github.io/tags/%E5%89%8D%E7%AB%AF/</link>
    <description>Recent content in 前端 on Luneshao</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Aug 2021 17:12:49 +0800</lastBuildDate><atom:link href="https://luneshao.github.io/tags/%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Table 相关的补充知识点</title>
      <link>https://luneshao.github.io/2021/2021-08-13-table/</link>
      <pubDate>Fri, 13 Aug 2021 17:12:49 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2021/2021-08-13-table/</guid>
      <description>1、 HTML table表格 固定表头 tbody加滚动条
2、 数字、字母文本溢出
&amp;lt;table class=&amp;#34;table&amp;#34;&amp;gt; &amp;lt;thead class=&amp;#34;thead&amp;#34;&amp;gt; ... &amp;lt;/thead&amp;gt; &amp;lt;tbody class=&amp;#34;tbody&amp;#34;&amp;gt; &amp;lt;tr v-for=&amp;#34;(item, index) in data&amp;#34; :key=&amp;#34;index&amp;#34;&amp;gt; &amp;lt;td&amp;gt;{{ item.account }}&amp;lt;/td&amp;gt; &amp;lt;td width=&amp;#34;46%&amp;#34;&amp;gt;{{ item.option }}&amp;lt;/td&amp;gt; &amp;lt;td width=&amp;#34;24%&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;link&amp;#34;&amp;gt; {{ item.link }} &amp;lt;/div&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;{{ item.duration }}&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; .table { .tbody { .link { word-wrap:break-word; word-break:break-all; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 1; //多行在这里修改数字即可 overflow:hidden; /* autoprefixer: ignore next */ -webkit-box-orient: vertical; } } } 3、 flex 布局 overflow 失效 Scrolling a flexbox with overflowing content</description>
    </item>
    
    <item>
      <title>一些js动画库</title>
      <link>https://luneshao.github.io/2020/2020-11-03-animate/</link>
      <pubDate>Tue, 03 Nov 2020 14:13:14 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-11-03-animate/</guid>
      <description>vivus 让svg动起来的库
使用方法参考这篇blog
svg库使用iconfinder
update: 原来我理解错了，不是只有那个库的可以，而是我很幸运又不幸的下载的第一个icon可以，后来和UI一起研究可以动的原因，是因为svg文件里有路径、线等一些元素，不可以的那些是整合起来了。
举个例子：
这个可以
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; ?&amp;gt;&amp;lt;svg style=&amp;#34;enable-background:new 0 0 48 48;&amp;#34; version=&amp;#34;1.1&amp;#34; viewBox=&amp;#34;0 0 48 48&amp;#34; xml:space=&amp;#34;preserve&amp;#34; xmlns=&amp;#34;http://www.w3.org/2000/svg&amp;#34; xmlns:xlink=&amp;#34;http://www.w3.org/1999/xlink&amp;#34;&amp;gt;&amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; .st0{display:none;} .st1{fill:none;stroke:#303030;stroke-width:0.7;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;} .st2{fill:#303030;} &amp;lt;/style&amp;gt;&amp;lt;g class=&amp;#34;st0&amp;#34; id=&amp;#34;Padding__x26__Artboard&amp;#34;/&amp;gt;&amp;lt;g id=&amp;#34;Icons&amp;#34;&amp;gt;&amp;lt;g&amp;gt;&amp;lt;path class=&amp;#34;st1&amp;#34; d=&amp;#34;M35.24081,27.28716l-0.00455,6.35106c0,1.51155-1.14731,2.74078-2.54954,2.74078H15.31331 c-1.41135,0-2.55866-1.22923-2.55866-2.74078l0.00455-6.34194c0.44616,0.06369,0.91055,0.08192,1.36583,0.05463l-0.00455,6.28731 c0,0.75578,0.53725,1.37495,1.19282,1.37495h17.37341c0.65557,0,1.18371-0.61917,1.18371-1.37495l0.00454-6.29643 C34.33026,27.37819,34.79465,27.35996,35.24081,27.28716z&amp;#34;/&amp;gt;&amp;lt;g&amp;gt;&amp;lt;path class=&amp;#34;st1&amp;#34; d=&amp;#34;M10.27793,24.09561c0,1.11998,1.12909,1.78469,2.47671,1.99412 c0.44617,0.07284,0.91056,0.09105,1.36583,0.05463c1.56616-0.10016,3.01394-0.78308,3.01394-2.04875&amp;#34;/&amp;gt;&amp;lt;path class=&amp;#34;st1&amp;#34; d=&amp;#34;M17.13774,24.09488c0,2.75728,6.86018,2.75728,6.86018,0&amp;#34;/&amp;gt;&amp;lt;path class=&amp;#34;st1&amp;#34; d=&amp;#34;M23.99791,24.09488c0,2.75728,6.86018,2.75728,6.86018,0&amp;#34;/&amp;gt;&amp;lt;path class=&amp;#34;st1&amp;#34; d=&amp;#34;M37.72207,24.09561c0,1.11998-1.1382,1.78469-2.48582,1.99412 c-0.44617,0.06374-0.91056,0.08195-1.36583,0.05463c-1.56615-0.10016-3.00483-0.78308-3.00483-2.04875&amp;#34;/&amp;gt;&amp;lt;path class=&amp;#34;st1&amp;#34; d=&amp;#34;M10.27793,24.09561l3.14709-11.43638c0.16876-0.61327,0.72645-1.03823,1.36252-1.03823h18.42491 c0.63607,0,1.19376,0.42495,1.36252,1.03823l3.14709,11.43638&amp;#34;/&amp;gt;&amp;lt;/g&amp;gt;&amp;lt;g&amp;gt;&amp;lt;path class=&amp;#34;st1&amp;#34; d=&amp;#34;M12.75919,27.29625c0.44617,0.06374,0.91056,0.08195,1.36583,0.05463&amp;#34;/&amp;gt;&amp;lt;path class=&amp;#34;st1&amp;#34; d=&amp;#34;M33.87497,27.34178c0.45528,0.03642,0.91966,0.01821,1.36583-0.05463&amp;#34;/&amp;gt;&amp;lt;/g&amp;gt;&amp;lt;line class=&amp;#34;st1&amp;#34; x1=&amp;#34;16.37364&amp;#34; x2=&amp;#34;24.56307&amp;#34; y1=&amp;#34;13.86694&amp;#34; y2=&amp;#34;13.86694&amp;#34;/&amp;gt;&amp;lt;line class=&amp;#34;st1&amp;#34; x1=&amp;#34;27.77735&amp;#34; x2=&amp;#34;30.0816&amp;#34; y1=&amp;#34;13.86694&amp;#34; y2=&amp;#34;13.86694&amp;#34;/&amp;gt;&amp;lt;/g&amp;gt;&amp;lt;/g&amp;gt;&amp;lt;/svg&amp;gt; 这个不可以
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; ?&amp;gt;&amp;lt;!DOCTYPE svg PUBLIC &amp;#39;-//W3C//DTD SVG 1.</description>
    </item>
    
    <item>
      <title>Vue Loader笔记</title>
      <link>https://luneshao.github.io/2020/2020-07-21-vue-loader/</link>
      <pubDate>Tue, 21 Jul 2020 17:06:16 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-07-21-vue-loader/</guid>
      <description>Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件。
  允许为 Vue 组件的每个部分使用其它的 webpack loader；
  允许在一个 .vue 文件中使用自定义块，并对其运用自定义的 loader 链；
  使用 webpack loader 将 &amp;lt;style&amp;gt; 和 &amp;lt;template&amp;gt; 中引用的资源当作模块依赖来处理；
  为每个组件模拟出 scoped CSS；
  在开发过程中使用热重载来保持状态。
  起步 每个 vue 包的新版本发布时，一个相应版本的 vue-template-compiler 也会随之发布。编译器的版本必须和基本的 vue 包保持同步，这样 vue-loader 就会生成兼容运行时的代码。这意味着你每次升级项目中的 vue 包时，也应该匹配升级 vue-template-compiler。
webpack 配置 除了通过一条规则将 vue-loader 应用到所有扩展名为 .vue 的文件上之外，请确保在你的 webpack 配置中添加 Vue Loader 的插件：
// webpack.config.js const VueLoaderPlugin = require(&amp;#39;vue-loader/lib/plugin&amp;#39;) module.</description>
    </item>
    
    <item>
      <title>网页的 Copyright 及备案信息该如何书写</title>
      <link>https://luneshao.github.io/2020/2020-07-16-copyright/</link>
      <pubDate>Thu, 16 Jul 2020 12:16:22 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-07-16-copyright/</guid>
      <description>copyright 格式 [symbol] [date] [author&amp;rsquo;s name] [statement of rights]
Copyright - 标记  The universally accepted symbol for a copyright is the letter C in a circle: ©. You can also use the word &amp;ldquo;copyright&amp;rdquo;.
 版权的通用符号是一个圆圈中的字母C：©。 您也可以使用“copyright”一词。这个标记需要放在版权标识的最前方。
copyright - 日期  For the copyright date, you&amp;rsquo;ll want to use only a year or years. Months or days are not used.
 您只需要写一年或年份范围，不需要写月、日。
一年或年份范围  If you keep a mix of old and new content in your copyrighted medium, your copyright date may be a range rather than a single year.</description>
    </item>
    
    <item>
      <title>Vue 中异步加载 AMap</title>
      <link>https://luneshao.github.io/2020/2020-05-26-vue-amap/</link>
      <pubDate>Tue, 26 May 2020 14:27:32 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-05-26-vue-amap/</guid>
      <description>前言 最近在优化之前写的网站，FP 大概要半分钟才能加载出来，emmm，我写的。。。
这个也是之前文章优化的一部分，因为我的网页中有用到地图，之前用的 vue-amap 组件，后来觉得这个引用 cdn 不知道怎么下手，就改成了直接用节点渲染，不用组件了。然后又查了异步加载的方式，发现了一个解决方案，但是后期又发现了这个解决方案的一些 bug，一通百度加自己尝试修改了一下。
正文 先贴一下原文的解决方案:
 1. 创建一个 AMap.js,路径&amp;rsquo;src/assets/js/AMap.js&#39;  // src/assets/js/AMap.js  export default function MapLoader() { // &amp;lt;-- 原作者这里使用的是module.exports  return new Promise((resolve, reject) =&amp;gt; { if (window.AMap) { resolve(window.AMap) } else { var script = document.createElement(&amp;#39;script&amp;#39;) script.type = &amp;#39;text/javascript&amp;#39; script.async = true script.src = &amp;#39;http://webapi.amap.com/maps?v=1.3&amp;amp;callback=initAMap&amp;amp;key=yourkey&amp;#39; script.onerror = reject document.head.appendChild(script) } window.initAMap = () =&amp;gt; { resolve(window.AMap) } }) } 2. 在任何.vue 文件中使用 // test.</description>
    </item>
    
    <item>
      <title>Vue 项目优化</title>
      <link>https://luneshao.github.io/2020/2020-05-20-vue-perf/</link>
      <pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-05-20-vue-perf/</guid>
      <description>1、字体优化 1.1 字体包压缩 使用 fontmin 这个库压缩字体包。（字体下载地址 字体下载网 ，这个下载的苹方简-常规可以被格式化。）
const Fontmin = require(&amp;#39;fontmin&amp;#39;) const srcPath = &amp;#39;./path/*.ttf&amp;#39; // 字体源文件 const destPath = &amp;#39;./path&amp;#39; // 输出路径 const text = &amp;#39;text&amp;#39; var fontmin = new Fontmin() .src(srcPath) .dest(destPath) .use( Fontmin.glyph({ text: text, hinting: false // keep ttf hint info (fpgm, prep, cvt). default = true  }) ) // 执行 fontmin.run(function (err, files, stream) { if (err) { console.error(err) // 异常捕捉  } console.</description>
    </item>
    
    <item>
      <title>nodejs、Nginx 处理跨域</title>
      <link>https://luneshao.github.io/2020/2020-04-20-nodejs-proxy/</link>
      <pubDate>Mon, 20 Apr 2020 10:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-04-20-nodejs-proxy/</guid>
      <description>http-proxy  安装包 http-proxy 全局安装 pm2 包 创建 src/server/index.js const url = require(&amp;#39;url&amp;#39;) const http = require(&amp;#39;http&amp;#39;) const axios = require(&amp;#39;axios&amp;#39;) const qs = require(&amp;#39;qs&amp;#39;) const httpProxy = require(&amp;#39;http-proxy&amp;#39;) const proxy = httpProxy.createProxyServer((options = { changeOrigin: true, target: &amp;#39;https://api.mysubmail.com&amp;#39; })) proxy.on(&amp;#39;proxyRes&amp;#39;, (proxyRes, req, res, options) =&amp;gt; { let body = [] proxyRes.on(&amp;#39;data&amp;#39;, function(chunk) { body.push(chunk) }) proxyRes.on(&amp;#39;end&amp;#39;, function() { body = Buffer.concat(body).toString() res.end(&amp;#39;my response to cli&amp;#39;) }) }) proxy.on(&amp;#39;error&amp;#39;, function(err, req, res) { res.</description>
    </item>
    
    <item>
      <title>如何让自己网站被google收录？</title>
      <link>https://luneshao.github.io/2019/google-console/</link>
      <pubDate>Thu, 13 Jun 2019 10:12:32 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2019/google-console/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;引言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近两个月一直在鼓捣这个博客，一直也只是用网址访问。最近，尝试在搜索引擎上搜索我博客的url、内容、标题，通通搜不到？？？然后，看了&lt;a href=&#34;https://support.google.com/webmasters/answer/7451184&#34;&gt;搜索引擎优化 (SEO) 新手指南&lt;/a&gt;。在 google console 上配置了站点地图并进行&lt;a href=&#34;https://support.google.com/webmasters/answer/9012289#url_can_be_on_google_issues&#34;&gt;网址检查&lt;/a&gt;（查看资源中某个网址的 Google 索引信息）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我的检查结果： &lt;em&gt;此网址未显示在 Google 搜索结果中&lt;/em&gt; 。（此时已经可以在 google 中检索到 url 了。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击查看详情 =&amp;gt; return ( 已抓取 - 尚未编入索引, 状态：已排除。 ) 查看&lt;a href=&#34;https://support.google.com/webmasters/answer/7440203#discovered__unclear_status&#34;&gt;状态报告指南&lt;/a&gt;去一条一条的排查。我的结果对应的解释：&lt;code&gt;Google 已抓取相应网页，但尚未将其编入索引。日后，该网页可能会被编入索引，也可能不会被编入索引；无论如何，您都无需重新提交该网址以供抓取。&lt;/code&gt; 那就只能静静的等待了。（目前已经搜到了。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面主要是摘要梳理了搜索引擎优化 (SEO) 新手指南一些相关知识点，帮助理解。&lt;/p&gt;
&lt;p&gt;官方文档先祭一下 &lt;a href=&#34;https://support.google.com/webmasters/answer/7451184&#34;&gt;搜索引擎优化 (SEO) 新手指南&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1术语&#34;&gt;1.术语&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://support.google.com/webmasters/answer/70897&#34;&gt;Google 搜索的工作方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google 按照以下三个基本步骤来生成基于网页的结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;抓取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编入索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;呈现（和排名）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引&lt;/strong&gt; - Google 会将所知道的全部网页存储在其“索引”中。每个网页的索引条目都会描述该网页的内容和位置（网址）。编入索引是指当 Google 抓取、读取网页并将其添加到索引的过程。例如：Google 今天已将我网站上的几个网页编入索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;抓取&lt;/strong&gt; - 寻找新网页或更新后的网页的过程。Google 会通过跟踪链接、读取站点地图或其他各种方式来发现网址。Google 通过抓取网页来寻找新增网页，然后（在适当的时候）将网页编入索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;抓取工具&lt;/strong&gt; - 从网络中抓取（提取）网页并将网页编入索引的自动化软件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Googlebot&lt;/strong&gt; - Google 抓取工具的通用名称。Googlebot 会持续不断地抓取网页。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SEO&lt;/strong&gt; - 搜索引擎优化：使您的网站更易于搜索引擎抓取和编入索引的过程；也可指从事搜索引擎优化的人员的职位名称，例如：我们刚刚聘请了新的 SEO 来提升我们在网络上的曝光度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2测试搜索结果&#34;&gt;2.测试搜索结果&lt;/h2&gt;
&lt;p&gt;在 google 中搜索 &lt;code&gt;site:example.com&lt;/code&gt;，尝试是否可以搜索到结果。如果可以搜索到，表明你的网站已经在索引中。搜不到，就继续向下看吧:)&lt;/p&gt;
&lt;h2 id=&#34;3如何让-google-收录您的内容&#34;&gt;3.如何让 Google 收录您的内容&lt;/h2&gt;
&lt;p&gt;最好的办法是提交&lt;a href=&#34;https://support.google.com/webmasters/answer/156184?hl=zh-Hans&amp;amp;ref_topic=4581190&#34;&gt;站点地图&lt;/a&gt; 。站点地图是网站上的一种文件，可告知搜索引擎网站上新增了网页或有更新的网页。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里，我的博客本来是在 google 搜索不到的，hugo 会在 public 文件夹自动生成站点地图。（如果没有使用hugo，&lt;a href=&#34;https://support.google.com/webmasters/answer/183668?hl=zh-Hans&amp;amp;ref_topic=4581190&#34;&gt;文章&lt;/a&gt;中也提供了一些在线生成站点地图的网址和工具，可以自行生成哟～）此时，需要我们做的就是在 Search Console 工具中，自行配置站点地图的 url，或者将其添加到您的 robots.txt 文件中。然后，在 google 输入 site:luneshao.github.io 就可以搜索到了。一小步进步啊！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4告诉-google-不应抓取哪些页面&#34;&gt;4.告诉 Google 不应抓取哪些页面&lt;/h2&gt;
&lt;p&gt;若为非敏感信息，则可以使用 robots.txt 阻止不必要的抓取。&lt;/p&gt;
&lt;h2 id=&#34;5帮助-google和用户了解您的内容&#34;&gt;5.帮助 Google（和用户）了解您的内容&lt;/h2&gt;
&lt;p&gt;诸位可以使用这个&lt;a href=&#34;http://analyzer.metatags.org/&#34;&gt;免费网站分析工具&lt;/a&gt;，分析一下自己的网站 seo 方面是否存在不足。&lt;/p&gt;
&lt;h3 id=&#34;51-创建唯一且准确的网页标题&#34;&gt;5.1 创建唯一且准确的网页标题&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; 标记可告诉用户和搜索引擎特定网页的主题是什么。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;unique title&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;52-创建恰当的标题和摘要以在搜索结果中显示&#34;&gt;5.2 创建恰当的标题和摘要以在搜索结果中显示&lt;/h3&gt;
&lt;p&gt;如果您的文档会显示在搜索结果页中，则 title 标记的内容可能会显示在相应结果的第一行&lt;/p&gt;
&lt;h3 id=&#34;53-使用description元标记&#34;&gt;5.3 使用“description”元标记&lt;/h3&gt;
&lt;p&gt;网页的说明元标记可让 Google 和其他搜索引擎了解该网页的大致内容。网页的标题可以是几个词或一个短语，而网页的说明元标记则可以是一两个句子或是一小段话。&lt;/p&gt;
&lt;h4 id=&#34;说明元标记有哪些好处&#34;&gt;说明元标记有哪些好处？&lt;/h4&gt;
&lt;p&gt;说明元标记很重要，因为 Google 可能会将其用作您网页的摘要。为每个网页添加说明元标记从来都是非常好的做法，以防 Google 找不到要在摘要中使用的恰当文字。&lt;/p&gt;
&lt;h3 id=&#34;54-使用标题标记强调重要文字&#34;&gt;5.4 使用标题标记强调重要文字&lt;/h3&gt;
&lt;p&gt;按顺序使用多种大小的标题可为您的内容创建层次结构，便于用户浏览文档。&lt;/p&gt;
&lt;h3 id=&#34;55-添加结构化数据标记&#34;&gt;5.5 添加结构化数据标记&lt;/h3&gt;
&lt;p&gt;结构化数据21是可添加到网站页面中的代码，用于向搜索引擎描述内容，以便搜索引擎更好地了解网页上的信息。搜索引擎可以利用这类信息在搜索结果中以有用的（且吸引用户的）方式显示您的内容。这也有助于您吸引到适合您业务的客户。&lt;/p&gt;
&lt;p&gt;例如，如果您有一个网店并且标记了一个单独的产品页面，这将帮助我们了解该页面主要显示自行车、自行车价格以及客户评价。我们可能会在相关查询的搜索结果的摘要中显示这些信息。我们将其称之为“富媒体搜索结果”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;富媒体搜索结果：Google 搜索结果中的增强型结果，具有额外的视觉效果或互动功能。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>强大的css filter属性及色彩名词（附 opacity 属性的兼容写法）</title>
      <link>https://luneshao.github.io/2019/css-filter/</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/css-filter/</guid>
      <description>引言
 最近公司需要找一个管理项目的工具，然后被推荐了 coding.net，我就看了一下官网的功能介绍。看到合作伙伴那里，hover 之后，图片变了颜色。然后，职业病就犯了，就看了一下人家是怎么实现的。
讲道理，我找了半天是怎么换的颜色。filter 这个属性之前看到是用来兼容 ie 的 opacity 属性的，我也一直没有用过，就以为它就是透明度的属性，我就没勾掉试一试。。。有点愚蠢。我就以为是换了图片的 URL，结果图片的 URL 并没有变化。我查看了图片，它本来的颜色就是彩色的。然后猜测，难道是利用 css 改变了图片的颜色？？？我就挨个属性勾了勾，果然是 filter 的原因。。
默认的 css 属性中，有这么一句 filter: grayscale(100%); ，这就是让图片变灰的属性。然后，就滚去 MDN 了。首屏就是几个例子，我又震惊了！这个属性可以做这么多事！！上一次震惊是在发现了 object-fit 属性，竟然可以改变图片内容的尺寸！
（文档真的要认真看，仔细看，可能某个小括号里边就提供了一种简便方法或者功能介绍。）
本篇主要是摘要了 MDN 的 filter 属性、取值及示例图以及关于色相、饱和度、灰度的概念。末尾附上了一份 opacity 的兼容性写法。
定义 filter：滤镜。
filter CSS属性将模糊或颜色偏移等 图形效果应用于元素 。滤镜通常用于调整图像，背景和边框的渲染。 CSS标准里包含了一些已实现预定义效果的函数。你也可以参考一个SVG滤镜，通过一个URL链接到SVG滤镜元素(SVG filter element)。
语法 共分为四类。具体的我就不搬运了，下面具体介绍。形式语法
/* 自定义的 SVG 滤镜 */ .filter: url(&amp;#34;filters.svg#filter-id&amp;#34;) /* 滤镜函数 */ blur、brightness、contrast、drop-shadow、grayscale、hue-rotate invert、opacity、saturate、sepia .filter: blur(5px); /* 混合滤镜 */ filter: contrast(175%) brightness(3%); /* Global values */ filter: inherit; filter: initial; filter: unset; 函数 url: URL函数接受一个XML文件，该文件设置了一个 SVG滤镜 ，且可以包含一个锚点来指定一个具体的滤镜元素.</description>
    </item>
    
    <item>
      <title>window.requestAnimationFrame方法</title>
      <link>https://luneshao.github.io/2019/window-requestanimationframe/</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/window-requestanimationframe/</guid>
      <description>原文链接伯乐 MDN
概念 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。
个人理解：raf 这个函数可以用来做动画，它需要一个参数，参数的形式是一个回调函数，在回调函数里可以写需要执行的动画。
这个回调函数会默认接收一个参数，即执行回调函数时的时间戳，回调函数，会在每次浏览器在下次重绘前执行回调函数更新动画，个人认为这样来保证动画的帧率和稳定性。大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次，相当于每帧的执行时间为 16.67ms。
特性   参数中的回调函数执行次数通常是每秒60次，速度大约为 16.67ms 每帧。
  当requestAnimationFrame()运行在后台标签页或者隐藏的&amp;lt;iframe&amp;gt; 里时，requestAnimationFrame() 会被暂停调用。对比 setTimeout ，离开页面依旧会计时，raf 更加节省性能。
  DOMHighResTimeStamp指示由 RequestAnimationFrame() 排队的回调开始触发的时间。
  它返回一个整数，表示定时器的编号，这个值可以传递给 cancelAnimationFrame 用于取消这个函数的执行。
  使用方法 window.requestAnimationFrame(callback) function callback (timeStamp) { // 默认接收参数 timeStamp，表示开始执行回调函数的时刻  // 若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()  window.requestAnimationFrame(callback) } 避免一帧多次调用 let ifCurFra = false // 当前帧是否执行  function cb (timeStamp) { if (ifCurFra) return ifCurFra = true window.requestAnimationFrame(timeStamp =&amp;gt; { ifCurFra = false }) } window.</description>
    </item>
    
    <item>
      <title>CSS Tranform 的 Matrix函数</title>
      <link>https://luneshao.github.io/2019/css-matrix/</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/css-matrix/</guid>
      <description>插播一句：translate 的百分比是相对于自身的宽高计算的。
插播2：计算角度值 eg：已知 sin(a) = 1，求 a？。 a = Math.asin(1) * 180 / Math.PI
 引言
 这也是关于优化 js 代码衍生出来的内容，过程是这样的。
 文章里说 Array.from 代替 Array.prototype.slice.call(arrayLike)，😳Array.prototype.slice.call(arrayLike) 是不是截取数组的嘛，查了一下文档 MDN ，原来将这个方法绑定到类数组对象/集合上，就可以转化为一个数组。过程中，看到了这篇博客，大佬是真的🐂🍺，里边就写到了计算用window.getComputedStyle(dom, 伪类) 获取值，本来我是忽略过去的，但是，好奇心让我测试了一下。。得到了一个这个东西。  这是啥？我不认识啊？？还是乖乖的学一下吧。
translate 值的计算 于是学习了 张鑫旭前辈的文章，这是一个矩阵，是transform变换的基础。我们可以根据这个矩阵里面的值推算出，transform 属性的值。
其格式为：Matrix(a, b, c, d, e, f) 具体的介绍请直接看前辈文章的第五节。
借前辈图，translate &amp;amp; scale 的转换公式如下。 ：
 x, y ：表示转换元素的所有坐标（变量）矩阵偏移元素的中心点。 ax+cy+e ：变换后的x坐标 bx+dy+f ：变换后的y坐标  scale 值的计算 matrix(s, 0, 0, s, 0, 0); s 即为 scale 的值。</description>
    </item>
    
    <item>
      <title>=8 一些不常用的获取元素属性的操作</title>
      <link>https://luneshao.github.io/2019/element-expland/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/element-expland/</guid>
      <description>1. 获取元素的css  1.1 window.getComputedStyle()  返回另一个包含所有 css 属性的对象，该对象应用了样式表并解析了基础计算（只读）。
window.getComputedStyle().getPropertyValue(&amp;#39;font&amp;#39;) // 获取属性 font 值 MDN 张鑫旭前辈的文章
css 安全(blog)
2.获取元素的大小及其相对于视口的位置  2.1 Element.getComputedStyle()  MDN
返回元素的大小及其相对于视口的位置。
如果你需要获得相对于整个网页左上角定位的属性值，那么只要给top、left属性值加上当前的滚动位置
（通过window.scrollX和window.scrollY），这样就可以获取与当前的滚动位置无关的值。
3.返回当前document对象所关联的window对象  3.1 document.defaultView  MDN
该属性返回当前 document 对象所关联的 window 对象，如果没有，会返回 null。
在许多在线的演示代码中，getComputedStyle是通过 document.defaultView 对象来调用的。大部分情况下，这是不需要的，因为可以直接通过window对象调用。但有一种情况，你必需要使用 defaultView, 那是在firefox3.6上访问子框架内的样式。</description>
    </item>
    
    <item>
      <title>js 代码美化 (持续更新)</title>
      <link>https://luneshao.github.io/2019/js-beauty/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/js-beauty/</guid>
      <description>github完整文章连接
Objects  1.1 将简写属性，放在对象定义的开始部分。  // bad const obj = { key1: 2, key2, key3: 2, } // good const obj = { key2, key4, key1: 2, key3: 2, }  1.2 不要直接调用 Object.prototype，例如 hasOwnProperty， propertyIsEnumerable，  因为这些名字没有被 Javascript 保留，如果被重新定义就会被覆盖。所以，最好是在原型链上调用。
MDN相关连接
// bad const a = obj.hasOwnProperty(&amp;#39;name&amp;#39;) // good const a = Object.prototype.hasOwnProperty.call(obj, &amp;#39;name&amp;#39;) // best // has.js const has = Object.prototype.hasOwnProperty // use.js import has from &amp;#39;./has.js&amp;#39; const a = has.</description>
    </item>
    
    <item>
      <title>CSS 的 clip 属性</title>
      <link>https://luneshao.github.io/2019/css-clip/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/css-clip/</guid>
      <description>参考文献：MDN 张鑫旭前辈的文章
介绍 定义 clip 属性剪裁元素，属性仅应用于绝对定位元素，例如 position: absolute 或 position: fixed。
属性值   auto：不剪裁。
  &amp;lt;shape&amp;gt;：截取的形状，值的表示方式 rect(&amp;lt;top&amp;gt;, &amp;lt;right&amp;gt;, &amp;lt;bottom&amp;gt;, &amp;lt;left&amp;gt;) 或 rect(&amp;lt;top&amp;gt; &amp;lt;right&amp;gt; &amp;lt;bottom&amp;gt; &amp;lt;left&amp;gt;)。
  top &amp;amp; bottom 设置的是距离元素上边距的距离。left &amp;amp; right 设置的是距离元素左边距的距离。
左侧使用了clip属性，左右容器和图片的尺寸都是200 * 200。 top、right、bottom、left 的值可以是 数值 或 auto 。
tips：auto表示 If any side&amp;rsquo;s value is auto, the element is clipped to that side&amp;rsquo;s inside border edge. （文档） 截取到元素该边的内边界。
 inherit：从父元素继承 clip 属性的值，不兼容 IE6。   实例</description>
    </item>
    
    <item>
      <title>js Date 对象</title>
      <link>https://luneshao.github.io/2019/js-date/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/js-date/</guid>
      <description>参考文献：MDN
常用方法 语法 new Date()： 返回一个 Date 对象new Date(value)：new Date(dateString)：new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])：Date() : 以函数形式直接调用 Date()，返回一个字符串
new Date() 参数 (value)： 一个整数值，表示自1970年1月1日00:00:00 UTC（the Unix epoch）以来的毫秒数。(dateString)： 表示日期的字符串值。(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])：year：表示年份的整数值。
monthIndex：表示月份的整数值，从 0（1月）到 11（12月）。
day：表示一个月中的第几天的整数值，从1开始。
hours：小时数的整数值 (24小时制)。
minutes：时间中分钟部分的整数值。
seconds：时间中的秒部分的整数值。
milliseconds：时间的毫秒部分的整数值。
方法 Date.now()： 返回自 1970-1-1 00:00:00 UTC（世界标准时间）至今所经过的毫秒数。
Date.parse()： 解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。
Date.UTC()： 接受和构造函数最长形式的参数相同的参数（从2到7），并返回从 1970-01-01 00:00:00 UTC 开始所经过的毫秒数。</description>
    </item>
    
    <item>
      <title>=8 浏览器易混淆名词整理</title>
      <link>https://luneshao.github.io/2019/browser-num/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/browser-num/</guid>
      <description>1.JS 的 window.location 对象 包含有关文档及当前位置的信息。
MDN文档地址
  location.origin: 包含页面来源的域名的标准形式，当前页面的域名 + 端口。 eg: https://www.baidu.com
  location.host: 当前页面的域名，可能最后带有一个“：”和端口。 eg: www.baidu.com
  location.hostname: 当前页面的域名。 eg: www.baidu.com
  location.protocol: 当前页面的协议。 eg: https
  location.assign(): 加载给定 URL 的内容到这个 Location对象所关联的对象上。
  location.reload(params): 重新加载当前页。params: t/f =&amp;gt; 服务器请求资源/缓存。
  location.replace(): 用给定的URL替换当前的资源，不会被保存历史。
  2.ajax 请求头中的属性 MDN文档地址
  Host: 服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的TCP端口号。 相关文章一个IP可以部署众多网站，分别解析不同的域名，host 指示访问哪个虚拟主机。
  Origin: 请求来自于哪个站点，该字段仅指示服务器名称，并不包含任何路径信息。
  Referer: 当前请求页面的来源页面的地址。B -&amp;gt; A, Referer: B.</description>
    </item>
    
    <item>
      <title>前端属性兼容性整理</title>
      <link>https://luneshao.github.io/2019/comp/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/comp/</guid>
      <description>1.document 相关 1.1 addEventListen
兼容写法：
function addEvt(eTarget, eType, eHandle) { if (eTarget.addEventListen) { eTarget.addEventListen(eType, eHandle) } else { // ie 浏览器  if (eTarget.attachEvent) { eType = &amp;#39;on&amp;#39; + eType eTarget.attachEvent(eType, eHandle) } else { eventTarget[&amp;#39;on&amp;#39; + eventType] = eventHandler } } } 1.2 scrollTop()
兼容写法：
// 因为 0 || undefine =&amp;gt; undefined const st = document.pageYOffset.scrollTop || document.documentElement.scrollTop || document.body.scrollTop || 0 // ie6/7/8 1. 没有 doctype 声明的页面： const st = document.</description>
    </item>
    
  </channel>
</rss>
