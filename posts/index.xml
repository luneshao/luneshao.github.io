<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Luneshao</title>
    <link>https://luneshao.github.io/posts/</link>
    <description>Recent content in Posts on Luneshao</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 May 2020 22:00:37 +0800</lastBuildDate>
    
	<atom:link href="https://luneshao.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>借助 Chrome 进行性能优化</title>
      <link>https://luneshao.github.io/2020/2020-05-27-chrome-performance/</link>
      <pubDate>Wed, 27 May 2020 22:00:37 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-05-27-chrome-performance/</guid>
      <description>运行时性能是指页面运行时的表现，而不是加载时的表现。本教程将教您如何使用 Chrome DevTools 性能面板分析运行时性能。就 RAIL 模型而言，本教程中学习的技能对于分析页面的响应、动画和空闲阶段非常有用。
分析结果 1. 分析每秒的帧数 衡量任何动画性能的主要指标是每秒帧数（FPS）。当动画以 60 FPS 运行时，用户会感到舒适。
 查看 FPS 图表。只要您在 FPS 上方看到红色条，就表示帧速率下降得很低，以至于可能损害用户体验。通常，绿色条越高，FPS 越高。
 在 FPS 图表下方，您会看到 CPU 图表。 CPU 图表中的颜色与 Performance 面板底部的 Summary 选项卡中的颜色相对应。CPU 图表充满色彩的事实意味着在记录过程中 CPU 已满。每当您看到 CPU 长时间长时间处于工作状态时，它意味着需要寻找办法减少工作。
 将鼠标悬停在 FPS，CPU 或 NET 图表上。 DevTools 将显示该时间点的页面截图。左右移动鼠标以重播记录。这称为 scrubbing ，对于手动分析动画的进度很有用。
 在 Frames 部分中，将鼠标悬停在绿色方块之一上。 DevTools 为您显示该特定框架的 FPS。每帧可能远低于 60 FPS 的目标。
  当然，通过此 demo，很明显页面效果不佳。但是在实际情况下，可能还不是很清楚，因此拥有所有这些工具进行测量非常方便。
打开 FPS 仪表 另一个方便的工具是 FPS 测量仪，它可以在页面运行时提供 FPS 的实时估算。</description>
    </item>
    
    <item>
      <title>Vue 中异步加载 AMap</title>
      <link>https://luneshao.github.io/2020/2020-05-26-vue-amap/</link>
      <pubDate>Tue, 26 May 2020 14:27:32 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-05-26-vue-amap/</guid>
      <description>前言 最近在优化之前写的网站，FP 大概要半分钟才能加载出来，emmm，我写的。。。
这个也是之前文章优化的一部分，因为我的网页中有用到地图，之前用的 vue-amap 组件，后来觉得这个引用 cdn 不知道怎么下手，就改成了直接用节点渲染，不用组件了。然后又查了异步加载的方式，发现了一个解决方案，但是后期又发现了这个解决方案的一些 bug，一通百度加自己尝试修改了一下。
正文 先贴一下原文的解决方案:
 1. 创建一个 AMap.js,路径&amp;rsquo;src/assets/js/AMap.js&amp;rsquo;  // src/assets/js/AMap.js export default function MapLoader() { // &amp;lt;-- 原作者这里使用的是module.exports return new Promise((resolve, reject) =&amp;gt; { if (window.AMap) { resolve(window.AMap) } else { var script = document.createElement(&#39;script&#39;) script.type = &#39;text/javascript&#39; script.async = true script.src = &#39;http://webapi.amap.com/maps?v=1.3&amp;amp;callback=initAMap&amp;amp;key=yourkey&#39; script.onerror = reject document.head.appendChild(script) } window.initAMap = () =&amp;gt; { resolve(window.AMap) } }) }  2. 在任何.vue 文件中使用 // test.</description>
    </item>
    
    <item>
      <title>网页加载相关事件梳理</title>
      <link>https://luneshao.github.io/2020/2020-05-26-perfomace/</link>
      <pubDate>Tue, 26 May 2020 09:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-05-26-perfomace/</guid>
      <description>浏览器的页面的加载流程 [from Chrome的First Paint]  浏览器输入 url，浏览器发送请求到服务器，服务器将请求的HTML返回给浏览器。 浏览器下载完成 HTML(Finish Loading HTML) 之后，便开始从上到下解析。 解析的过程中碰到 css 和 js 外链（其实 HTML 的下载也是这个流程）都会执行以下过程：  Send Request: 表示给这个外链对应的服务器发送请求 Receive Response: 表示接收响应，这里是表示告诉浏览器可以开始从网络接收数据了 Receive Data: 表示开始接收数据 Finish Loading: 表示已经完成下载数据。 Parse Stylesheet/Evaluate（默认情况下 js 下载完成之后执行 Evaluate，css 下载完成后会进行Parse Stylesheet）  所有的 css 下载完成后 Parse Stylesheet 然后开始构建 CSSOM DOM（文档对象模型）和 CSSOM（CSS对象模型）会合并生成一个渲染树(Render Tree) 根据渲染树的内容计算出各个节点在网页中的大小和位置（Layout，可以理解为“刻章”） 根据 Layout 绘制内容在浏览器上（Paint，可以理解为“盖章”）。  页面加载相关事件名词解释 [图片 from Chrome的First Paint]
 FP(First Paint)  First paint，直译过来的意思就是浏览器第一次渲染(paint)，在 First paint 之前是白屏，在这个时间点之后用户就能看到（部分）页面内容。[from Chrome的First Paint]</description>
    </item>
    
    <item>
      <title>Nginx 相关文章汇总</title>
      <link>https://luneshao.github.io/2020/2020-05-21-nginx/</link>
      <pubDate>Thu, 21 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-05-21-nginx/</guid>
      <description>1、nginx 重启相关文章 Nginx怎么重启
 进入nginx可执行目录sbin下，输入命令./nginx -s reload ，即可。
 2、nginx 配置 gzip nginx中如何设置gzip（总结）</description>
    </item>
    
    <item>
      <title>Vue 项目优化</title>
      <link>https://luneshao.github.io/2020/2020-05-20-vue-perf/</link>
      <pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-05-20-vue-perf/</guid>
      <description>1、字体优化 1.1 字体包压缩 使用 fontmin 这个库压缩字体包。（字体下载地址 字体下载网 ，这个下载的苹方简-常规可以被格式化。）
const Fontmin = require(&#39;fontmin&#39;) const srcPath = &#39;./path/*.ttf&#39; // 字体源文件 const destPath = &#39;./path&#39; // 输出路径 const text = &#39;text&#39; var fontmin = new Fontmin() .src(srcPath) .dest(destPath) .use( Fontmin.glyph({ text: text, hinting: false // keep ttf hint info (fpgm, prep, cvt). default = true }) ) // 执行 fontmin.run(function (err, files, stream) { if (err) { console.error(err) // 异常捕捉 } console.log(&#39;done&#39;) // 成功 })  1.</description>
    </item>
    
    <item>
      <title>Chrome 上网插件 setupVPN</title>
      <link>https://luneshao.github.io/2020/2020-04-29-setupvpn/</link>
      <pubDate>Wed, 29 Apr 2020 09:50:55 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-04-29-setupvpn/</guid>
      <description></description>
    </item>
    
    <item>
      <title>nodejs、Nginx 处理跨域</title>
      <link>https://luneshao.github.io/2020/2020-04-20-nodejs-proxy/</link>
      <pubDate>Mon, 20 Apr 2020 10:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-04-20-nodejs-proxy/</guid>
      <description>http-proxy  安装包 http-proxy 全局安装 pm2 包 创建 src/server/index.js
const url = require(&#39;url&#39;) const http = require(&#39;http&#39;) const axios = require(&#39;axios&#39;) const qs = require(&#39;qs&#39;) const httpProxy = require(&#39;http-proxy&#39;) const proxy = httpProxy.createProxyServer((options = { changeOrigin: true, target: &#39;https://api.mysubmail.com&#39; })) proxy.on(&#39;proxyRes&#39;, (proxyRes, req, res, options) =&amp;gt; { let body = [] proxyRes.on(&#39;data&#39;, function(chunk) { body.push(chunk) }) proxyRes.on(&#39;end&#39;, function() { body = Buffer.concat(body).toString() res.end(&#39;my response to cli&#39;) }) }) proxy.on(&#39;error&#39;, function(err, req, res) { res.</description>
    </item>
    
    <item>
      <title>日语输入法</title>
      <link>https://luneshao.github.io/2020/2020-04-09-riyupinyin/</link>
      <pubDate>Thu, 09 Apr 2020 10:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-04-09-riyupinyin/</guid>
      <description>清音             あ A い I う U え E お O   か KA き KI く KU け KE こ KO   さ SA し SI す SU せ SE そ SO   た TA ち TI つ TU て TE と TO   な NA に NI ぬ NU ね NE の NO   は HA ひ HI ふ HU へ HE ほ HO   ま MA み MI む MU め ME も MO   や YA や YA ゆ YU や YA よ YO   ら RA り RI る RU れ RE ろ RO   わ WA を WO ん NN      浊音?</description>
    </item>
    
    <item>
      <title>node-fluent-ffmpeg 文档</title>
      <link>https://luneshao.github.io/2020/2020-04-07-fluent-ffmpeg-api/</link>
      <pubDate>Tue, 07 Apr 2020 10:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-04-07-fluent-ffmpeg-api/</guid>
      <description>node-fluent-ffmpeg 该库将 ffmpeg 的复杂命令行用法抽象为一个流畅，易于使用的 node.js 模块。为了能够使用此模块，请确保在系统上安装了ffmpeg（包括所有必需的编码库，如 libmp3lame 或 libx264）。
安装 npm
$ npm install fluent-ffmpeg  yarn
$ yarn add fluent-ffmpeg  或者作为一个 submodule
$ git submodule add git://github.com/schaermu/node-fluent-ffmpeg.git vendor/fluent-ffmpeg  用法 你将在 examples 文件夹中找到一些有用的例子。
先决条件 ffmpeg and ffprobe fluent-ffmpeg 需要 ffmpeg&amp;gt; = 0.9 才能工作。它可能与以前的版本一起使用，但是一些功能将不可用（并且不再对库进行较低版本的测试）。
如果设置了 FFMPEG_PATH 环境变量，fluent-ffmpeg 会将其用作 ffmpeg 可执行文件的完整路径。否则，它将尝试直接调用 ffmpeg（因此它应该在您的 PATH 中）。您还必须安装 ffprobe（大多数发行版随附 ffmpeg）。同样，fluent-ffmpeg 将使用 FFPROBE_PATH 环境变量（如果已设置），否则它将尝试在 PATH 中调用它。
当使用 avconv 和 avprobe 而不是 ffmpeg 和 ffprobe 时，大多数功能都可以使用，但是目前尚不正式支持。</description>
    </item>
    
    <item>
      <title>修改腾讯云默认远程连接端口</title>
      <link>https://luneshao.github.io/2020/2020-04-02-tencent-server-ssh/</link>
      <pubDate>Thu, 02 Apr 2020 10:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-04-02-tencent-server-ssh/</guid>
      <description>引子 话说去年夏天，腾讯云最低端配置的服务器两百多可以包三年，我就冲了一台给自己瞎鼓捣东西用。最近在测试Jekyll的自动部署就又把服务器用起来了，然后，这两天就提示越南的IP异常登录，emmm，我又不太懂，怕服务器被黑了，就查了下解决办法。然后，就看到了腾讯云防暴力破解防异地登陆。然后，就踩了一个小坑“修改ssh远程登陆端口后，ssh连接一直connect refused”所以记录下。
正文 文章中的步骤： &amp;gt; 1、 vim /etc/ssh/sshd_config,将#Port 22解注释，然后改成其他端口，最后重启sshd服务 &amp;gt; 2、 重启sshd服务： systemctl restart sshd &amp;gt; 3、 在腾讯云安全组开放你的端口，来源最好绑定自己ip
这里步骤是完全没问题的，但是不完整。下面我补充一下：
 5、 根据修改云服务器远程默认端口这篇文章，在执行完第二步之后需要配置下防火墙，放行新增端口。 6、 也就是我踩的坑。重启实例。具体原因我不清楚，但是不重启的话，我修改的远程端口配置就不生效。如果大佬们清楚原因还望赐教，感谢。  补充腾讯云其他操作 一、使用ssh方式远程连接服务器 参考腾讯云购买以及配置ssh密钥登录 为了安全，在本地生成公钥、私钥配置到实例中。 步骤： - 1、 本地执行 ssh-keygen -t rsa ,然后会出现如下内容：
Generating public/private rsa key pair. Enter file in which to save the key (/Users/apple/.ssh/id_rsa):  可以在此时输入自定义的ssh文件名，默认的是 id_rsa，为了区分我修改为 id_rsa_tencent-server。之后可以一路回车，如果想设置密码可以设置，我嫌麻烦没设置。 - 2、 本地配置ssh对应的hostname及端口：
$ cd ~/.ssh $ vi config （键盘键入 i 输入内容） $ Host tencent UseKeychain yes User root Port 8888 HostName 8.</description>
    </item>
    
    <item>
      <title>Jekyll 搭建博客步骤</title>
      <link>https://luneshao.github.io/2020/2020-03-23-jekyll-blog/</link>
      <pubDate>Mon, 23 Mar 2020 10:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-03-23-jekyll-blog/</guid>
      <description>分布教程 1. Setup installation 安装 Jekyll
gem install jekyll bundler  创建 Gemfile
bundle init  编辑 Gemfile，添加 Jekyll 作为依赖
gem &amp;quot;jekyll&amp;quot;  运行 bundle 安装 Jekyll 到项目。
bundle  现在可以在 Jekyll 的命令前加上 bundle exec，以确保使用 Gemfile 中的 Jekyll 版本。
Create a site 为网站创建一个目录，名称可以任意起。在教程的其余部分，将称其为 root. 在 root 目录添加第一个文件 index.html。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt; &amp;lt;title&amp;gt;Home&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  build Jekyll 是静态网站生成器，因此我们需要 Jekyll 构建网站才能查看。您可以在网站的根目录中运行以下两个命令来构建它：
 jekyll build：构建网站输出静态站点到名为 _site 的目录下。 jekyll serve：除了在您进行更改并运行本地 Web 服务器时会重新生成之外，还会运行一个 web 服务在 http://localhost:4000  2.</description>
    </item>
    
    <item>
      <title>html 回滚</title>
      <link>https://luneshao.github.io/2020/2020-03-22-html-note/</link>
      <pubDate>Sun, 22 Mar 2020 10:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-03-22-html-note/</guid>
      <description>文本修饰标签 &amp;lt;b&amp;gt;加粗文本&amp;lt;/b&amp;gt; &amp;lt;s&amp;gt;删除线&amp;lt;/s&amp;gt; &amp;lt;u&amp;gt;下划线&amp;lt;/u&amp;gt; &amp;lt;sup&amp;gt;上标&amp;lt;/sup&amp;gt; &amp;lt;sub&amp;gt;下标&amp;lt;/sub&amp;gt; &amp;lt;font&amp;gt;字体标记&amp;lt;/font&amp;gt; &amp;lt;!-- 不常用属性 size: 文本大小，1-7。 color: 颜色值。 face: 字体。 --&amp;gt;  排版标签 p &amp;lt;p align=&amp;quot;center&amp;quot;&amp;gt;段落&amp;lt;/p&amp;gt;  不常用属性  align: 水平对齐方式，取值：left、center、right  hr &amp;lt;hr size=&amp;quot;2px&amp;quot; color=&amp;quot;yellow&amp;quot; width=&amp;quot;10px&amp;quot; noshade /&amp;gt;  不常用属性  size: 水平线的粗细，单位一般为 px。 color: 颜色。 width: 宽度。 noshade: 去掉水平线的阴影。  字符实体 &amp;lt;: &amp;amp;lt; &amp;gt;: &amp;amp;gt; &amp;amp;: &amp;amp;amp; &amp;yen;: &amp;amp;yen; &amp;times;: &amp;amp;times; &amp;divide;: &amp;amp;divide;
列表 ul &amp;lt;ul type=&amp;quot;circle&amp;quot;&amp;gt; &amp;lt;li&amp;gt;无序列表&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;  不常用属性  type: 符号类型，circle、square、disc。  ol &amp;lt;ol type=&amp;quot;a&amp;quot; start=&amp;quot;3&amp;quot;&amp;gt; &amp;lt;li&amp;gt;有序列表&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt;  不常用属性  type: 编号类型，取值：1、a、A、i、I。 start: 从第几个开始编号(数字)。  图片标签 img &amp;lt;img align=&amp;quot;right&amp;quot; hspace=&amp;quot;10px&amp;quot; vspace=&amp;quot;10px&amp;quot; /&amp;gt;  不常用属性  align: 图片的水平对齐方式，取值：left、center、right (Align 属性只能让文本居中，不能让图片单独居中。) hspace: 图片与左右文字之间的距离(水平距离) vspace: 图片与上下文字之间的距离(垂直距离)  meta 标签 &amp;lt;meta&amp;gt;的主要作用，是提供网页的元信息。 标记有两个属性：http-equiv 和 name。</description>
    </item>
    
    <item>
      <title>vue 笔记</title>
      <link>https://luneshao.github.io/2020/2020-03-20-vue/</link>
      <pubDate>Fri, 20 Mar 2020 10:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-03-20-vue/</guid>
      <description> 不要在选项属性或回调上使用箭头函数，比如 created: () =&amp;gt; console.log(this.a) 或 vm.$watch(&amp;lsquo;a&amp;rsquo;, newValue =&amp;gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。
 可以在二级目录线上部署项目
// vue.config.js module.exports = { publicPath: &#39;./&#39;, }  </description>
    </item>
    
    <item>
      <title>质量管理</title>
      <link>https://luneshao.github.io/2020/2020-03-19-zlgl/</link>
      <pubDate>Thu, 19 Mar 2020 10:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-03-19-zlgl/</guid>
      <description>1、质量：根据国家标准GB／T6583—94，质量被定义为“反映实体满足明确或隐含需要的能力的特性总和”。 2、实体：可单独描述和研究的事物，它可以是活动和过程，也可以是产品，也可以是组织、体系、人以及上述各项的任何组合。 3、产品：某一活动和过程的结果。 4、产品质量：反映产品满足明确或隐含需要的能力的特性总和。 5、真正质量特性：直接反映顾客对产品期望和要求的质量特性。 6、代用质量特性：企业为了满足顾客期望和要求，相应地制定产品标准、确定产品参数来间接地反映真正质量特性。 7、过程：将输入转化为输出的一组彼此相关的资源和活动。 8、质量环：从最初识别需要到最终满足要求和期望的各阶段中影响质量的相互作用活动的概念模式。又称为质量螺旋或产品寿命周期。 9、质量管理：国家标准GB／T6583—94给质量管理下的定义是：“确定质量方针、目标和职责，并在质量体系中通过诸如质量策划、质量控制、质量保证和质量改进使其实施的全部管理职能的所有活动。” 10、质量管理学：关于质量的一般规律、理论和方法的知识体系。通俗地说，就是研究产品质量产生、形成、实现过程客观规律的学科，既涉及经济学、管理学等社会科学，又涉及数学、数理统计等自然科学，并且与社会发展密切相关，因此属于“边缘学科”。 11、五方受益者：顾客、职工、所有者、供方、社会。 12、全面质量管理：国家标准(CB／T6583—94)《质量管理和质量保证——术语》中对全面质量管理的定义是：“一个组织以质量为中心，以全员参加为基础，目的在于通过让顾客满意和本组织所有成员及社会受益而达到长期成功的管理途径。”具体地说，全面质量管理就是以质量为中心，全体职工以及有关部门积极参与，把专业技术、经营管理、数理统计和思想教育结合起来，建立起产品的研究、设计、生产、服务等全过程的质量体系，从而有效地利用人力、物力、财力、信息等资源，以最经济的手段生产出顾客满意的产品，使组织、全体成员和社会均能受益，从而使组织获得长期成功和发展。 13、三全一多样：对全面质量管理的基本要求的概括。它是指：全员的质量管理、全过程的质量管理、全企业的质量管理和多方法的质量管理。 14、标准：国家标准GB／T39351—83对标准所下的定义是：“标准是对重复性事物和概念所做的统一规定，它以科学、技术和实践经验的综合为基础，经过有关方面协商一致，由主管机构批准，以特定的形式发布，作为共同遵守的准则和依据”。 15、标准化：国家标准GB／T3951—83对标准化下的定义是：“在经济、技术、科学及管理等社会实践中，对重复性事物和概念，通过制定、发布和实施标准，达到统一，以获得最佳秩序和社会效益。” 16、质量信息：反映企业产品质量和产供销各个环节的基本数据、原始记录以及产品使用过程中反映处理的各种情报资料。它是质量管理的耳目，也是一项重要的资源。 17、产品责任：制造者、销售者对用户使用该产品造成的伤亡、损害事故所应承担的法律责任。 18、质量成本：企业为保证产品质量而支出的一切费用以及由于产品质量未达到既定的标准而造成的一切损失的总和。是衡量企业质量管理活动和质量体系有效性的依据。 19、直接质量成本：在产品的制造和销售过程中所发生的质量成本，一般由内部故障成本、外部故障成本、鉴定成本和预防成本四个部分组成。 20、GB／T19000系列标准：GB／T19000系列标准是我国等同采用ISO9000系列标准而制定的。又称为双编号系列国家标准，写作GB／T19000一ISO9000.其标准名称为《质量管理与质量保　证》。它是一套精心设计、结构严谨、定义明确、内容具体和实用性强的管理标准，它包括“两个指南”和“三种质量保证模式”。“两个指南”是指一头一尾两个标准，即GB／T19000.1一ISO9000——1《质量管理和质量保证——选择和使用指南》和GB／T19004.1一ISO　9004—1《质量管理和质量体系要素指南》：“三种保证模式”是指GB／T19001一IS09001《质量体系——设计／开发、生产、安装和服务的质量保证模式》，GB／ T 19002一ISO 9002《质量体系——生产和安装的质量保证模式》和 GB／T 19003一ISO 9003《质量体系——最终检验和试验的质量保证模式》。 21、ISO 9000族：由ISO／TC176技术委员会制定的所有国际标准。TCl76指的是国际标准化组织的“质量管理和质量保证技术委员会”。目前，这些标准包括：IS0 9000至IS0 9004的所有国际标准和各分标准；ISO 10001至ISO 10020的所有国际标准和分标准；ISO 8402—94《质量管理和质量保证——术语》。ISO 9000族描述了质量体系包括的要素，而不是描述某一具体组织如何实施这些要素，它们不受具体的行业或经济部门所制约，只为质量管理提供指南和为质量保证提供通用的质量要求。 22、间接质量成本：在直接质量成本基础上进一步引伸和扩展，涉及制造和销售过程以外的企业活动。一般包括：无形的质量成本、，使用质量成本、供应商质量成本和设备质量成本等。 23、内部故障成本：企业内部由于生产的产品质量缺陷而造成的损失和处理质量缺陷而发生的费用总和。它一般包括：废品损失、返工费、复检和筛选费、停工损失、不合格品处理费等。 24、外部故障成本：在销售和使用中发现产品缺陷而产生的由制造企业支付的一切费用的总和。它一般包括：保修费、索赔费、诉讼费、退货费、降价费等。 25、鉴定成本：在“一次交验合格”的情况下，为检验产品质量而发生的一切费用。它通常包括：进货测试费、工序和成品检验费、在库物资复检费、对测试设备的评价费、质量评审费等。 26、预防成本：为了防止质量缺陷发生，保证产品质量，使故障成本和鉴定成本最低而耗费的费用。它通常包括：质量计划编制费、质量管理培训教育费、工序控制费、产品评审费、质量信息费、质量管理实施费等。 27、废品损失：制造的产品在经济上已不值得修复利用而发生的损失。 28、返工费：修复次品使之达到合格品的使用价值而支出的费用。 29、复检和筛选费：返修品的检验费、试验费，库存产品发生质量问题的检验费、试验费，抽检退回来的不合格品的筛选费等。 30、停工损失：产品在制造过程中发生质量缺陷而造成的停工损失。 31、索赔费：根据订货合同规定或其它有关的协议、承诺，赔偿顾客因产品质量问题而蒙受的经济损失所支出的费用。 32、诉讼费：为了证明顾客向法院提出的产品质量申述是否确实由于产品质量所致，企业派出专人调查和处理该项诉讼案所支出的费用。 33、保修费：根据订货合同规定或其它有关的协议、承诺，在保修期内对顾客提供技术服务的费用。 34、不合格品处理费：处理不合格品所花的人工、材料和设备费用。 35、退货费：产品出厂后，因质量问题而造成的退货、换货所支出的费用。 36、进货测试费：鉴定和评价外购原材料、半成品、工具、量具、配套件等的质量而发生的检验和试验费用。 37、在库物资复检费：对各种库存的材料、工装、半成品、成品等作定期检验、试验和维护保养的费用。 38、工序和成品检验费：产品在各道工序加工完毕和成品入库时的检验和试验费用。 39、对测试设备的评价费：对在用的仪器、仪表、工具、量具、计量基准等进行的日常维护保养、“周期检定”是计量标准中的专用术语等使之保持标准质量状态而支出的费用。 40、质量评审费：确定产品质量等级的评审费用。 41、产品评审费：设计方案评价、试制产品质量的评审等所发生的费用。 42、质量计划编制费：制定企业质量计划等方面的费用。 43、质量管理培训教育费：用于质量管理方面的一切培训教育活动费用。 44、工序控制费：为了确保产品质量而对工序能力进行调查、研究、评价以及制定工序质量分析表、建立控制点、使用控制图等方面的费用。 45、质量信息费：收集、整理、分析、保存全部质量信息的费用。 46、质量管理实施费：建立质量体系、召开各种质量会议、总结质量管理工作、奖励优秀的质量管理小组和个人等方面的费用。 47、质量职能：产品质量产生、形成和实现过程中全部活动的总和。它所包括的各项活动既有在企业内各部门所进行的活动，也有涉及企业外部的供应商、顾客等所进行的活动。可分为直接质量职能和间接质量职能。 48、质量职责：对企业各部门和各级各类人员在质量管理活动中所承担的任务、责任和权限的具体规定。 49、产品的社会需求分析：通过了解顾客现实的和隐含的需求以及顾客对产品的改进意见，确定产品的质量等级、数量、价格以及投放市场的时间。 50、报警信号：产品质量变劣的一种反映。包括：一定时期的顾客申诉、索赔、退货等的次数，一定时期销售额的下降情况，一定时期的保修费用额等。 51、营销：从质量管理学的角度看，是产品质量产生、形成和实现过程中的第一环，它的主要组成部分是市场调研，主要目的是识别顾客的需要，适当地确定产品质量要求并形成文件。 52、产品构思：又称产品设想。是在市场调研的基础上进行的。它是根据社会、自然环境、技术发展动向结合顾客的需要提出来的。开始时可能是一些含糊不清的想法，它可以由企业从事产品开发的技术人员提出来，也可以由企业职工，包括技术管理人员、销售人员、生产工人提出，还可以由顾客直接提出。 53、设计评审：为了评价设计满足质量要求的能力，识别问题（若有问题还要提出解决办法），从而对设计所作的综合的、有系统的并形成文件的检查。 54、设计验证：对某项规定的活动所进行的检查，以确定该项活动达到了规定的要求，这些规定要求主要是指产品规范。 55、设计确认：对最终产品在规定的使用条件下进行的、主要是为了确定该产品达到了顾客要求，满足顾客的需要。 56、初期评审：设计工作的基础和起点，这一阶段要求对方案作出概略的分析和论证工作，其内容偏重于对技术理论、设计原理以及技术经济效果和实现技术方案的可能性等方面的论证和评审。 57、中期评审：从设计开始至设计定型之前的评审工作。其特点是具体、深入、仔细，目的是验证产品设计的正确性。包括理论验证、模型验证和样机验证。 58、终期评审：在新产品样机试制之后进行的评审。重点是全面审查新产品各项性能指标与生产成本是否符合原定的各项要求，以便为投产做好准备，防止可能出现的各种问题。主要形式是设计定型鉴定和生产定型鉴定。 59、销售准备状态评审：确定组织是否有提供新产品或重新设计产品的能力。评审的主要内容包括：包装、操作、维护和修理手册是否齐全并适用；有适宜的销售和顾客售后服务；现场人员培训；备件提供情况；现场试用情况；完成鉴定试验情况；早期产品及其安装和标签的实际检验情况；生产设备的过程能力符合规范的证据。 60、设计再鉴定：也称事后评审，为了确保设计的持续有效，应定期对产品进行评价。其中包括根据现场经验、现场使用情况的调研或新工艺和新技术，对顾客的需要和技术规范进行复审。评价时还应考虑过程的修改，应保证更改不能导致产品质量的下降。 61、设计垄断：一个通病，是指设计部门对设计的决定已经达到不容别人挑剔的地步。除非产品试验或使用中出现了毛病，否则他们一般不会听取别人的意见。 62、关键件：含有一个或多个重要特性的单元件。关键特性是指如果该特性失效或损坏可能导致危及人身安全的后果或产品无法执行规定的任务。 63、重要件：含有一个或多个重要特性的单元件。重要特性是指该特性如果失效或损坏，可能迅速导致或显著影响最终产品不能完成要求的使命，但不会发生危及人身安全的后果。 64、可靠性：元件、产品、系统在一定时间内、在一定条件下无故障地执行指定功能的能力或可能性。可通过可靠度、失效率、平均无故障间隔时间、故障平均修复时间、维修度、有效度等指标来衡量。 65、可靠性技术：设计可靠性、制造可靠性和使用可靠性。 66、可靠性管理：为实现可靠性技术创造物质、人力等条件，以便最有效地达到预期可靠性目标的一系列活动。 67、田口方法：又称三次设计、稳健性设计。日本田口玄一博士所创建的一种设计方法。主要内容有两个方面：线内质量控制和线外质量控制。它适用于产品设计、科学试验、技术改新、工艺改革、材料研制等开发性领域，也适用于质量评价和质量改进等方面。 68、需要吸收型产品构思：企业产品研究与开发部门，根据市场需要，设计出新产品。由于产品开发与研究部门同市场进行了充分的双向交流，所以这种产品构思的成功性很大，盲目性很小，适用于中小企业开发产品。 69、技术推动型产品构思：企业产品开发与研究部门的人员，根据科学技术发展水平和本企业的技术实力，主动提出产品构思，促进顾客产生对新产品的需求。适用于技术水平高的大企业。 70、供应商调查：对供应商能力作出的一种预测。一般方法是派出一组有资格的观察员对供应商进行访问。观察员了解设备，研究各种程序，同负责人交谈并收集有关资料。通过这些工作，他们就能够对供应商是否有可能交付优质产品作出有用的预测。 71、对供应商的设计资格审查：根据供应商设计出来的样品进行试验，调查其设计控制工作，以判定供应商的能力或资格。 72、合格判定审核：为了简化人厂手续，提高检验工作效率，为了同供应商建立长期、稳定的关系，从而有效地保证产品质量，需方对供方的检验工作能力所做的审核。 73、对供应商的监督：为了保证供应商所提供的产品符合既定标准或适用性的要求而进行的一切活动。监督包括程序的、工艺的和产品的各种审核，以及购买者所执行的任何检。监督也属“早期报警”的范畴。 74、供应手册：又称“供应关系手册”。企业用来指导采购活动和处理同供应商关系的一种工具。 75、工序：产品、零部件制造过程的基本环节，是使其发生物理和化学变化的过程。包括加工、检验、搬运、停留四个环节。 76、工序能力：工序能够稳定地生产出产品的能力，也就是说在操作者、机器设备、原材料、操作方法、测量方法和环境等标准条件下，工序呈稳定状态时所具有的加工精度。常用标准偏差δ的6倍来表示工序能力的大小。 77、工序能力指数：表示工序能力对设计的产品规范的保证程度。 78、主导因素：在众多影响最后质量的因素中，起决定全局和占支配地位的因素。 79、质量控制点：在质量活动中需要重点进行控制的对象或实体。具体地说，是生产现场或服务现场在一定的期间内、一定的条件下对需要重点控制的质量特性、关键部位、薄弱环节，以及主导因素等采取特殊的管理措施和方法，实行强化管理，使工序处于良好控制状态，保证达到规定的质量要求。 80、关键特性：该质量特性如果失效或损坏，可能导致危及人身安全或产品无法执行规定的任务。</description>
    </item>
    
    <item>
      <title>边框追随鼠标</title>
      <link>https://luneshao.github.io/2020/2020-03-19-follow-mouse/</link>
      <pubDate>Thu, 19 Mar 2020 10:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2020/2020-03-19-follow-mouse/</guid>
      <description>feature  给盒子设置了图片边框 实现背景色角度追随鼠标移动改变  css 属性  border-image-slice：通过 border-image-source 引用边框图片后，border-image-slice属性会将图片分割为9个区域：四个角，四个边（edges）以及中心区域。四条切片线，从它们各自的侧面设置给定距离，控制区域的大小。    var t = document.querySelector(&amp;lsquo;.test&amp;rsquo;) t.onmousemove = function (e) { let r = (e.screenX + e.screenY) % 360
&amp;lt;!-- t.style.borderImage = `linear-gradient(${r}deg, #ffeead, #96ceb4) 2` --&amp;gt; t.style.backgroundImage = `linear-gradient(${360 - r}deg, #ffeead, #96ceb4)`  } 
code &amp;lt;!-- ... --&amp;gt; &amp;lt;style&amp;gt; .test { width: 100px; height: 100px; padding: 20px; border: dashed 70px; border-image: url(https://tse3-mm.cn.bing.net/th/id/OIP.GL_hNcihF8Q0N-HDKWzBngHaFj?w=288&amp;amp;h=216&amp;amp;c=7&amp;amp;o=5&amp;amp;dpr=2&amp;amp;pid=1.7); border-image-slice: 33% 33%; // 修改试试 border-radius: 50%; border-image-width: 90px; // 修改试试 background: linear-gradient(45deg, transparent, rgb(150, 206, 180)) repeat center center / 50px 50px; } &amp;lt;/style&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>深入理解eslint</title>
      <link>https://luneshao.github.io/2019/eslint/</link>
      <pubDate>Fri, 02 Aug 2019 10:36:26 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2019/eslint/</guid>
      <description>引言
参考文献：转载微信公众号的正文
文章结构：注释了一下 eslint.js 的各个配置项是什么意思，再也不会觉得像天书了（狗头
 // eslint.js module.exports = { root: true, // 如果root设置为true，那么 ESLint 就会认为当前目录为根目录，不再向上查找配置。 parser: &#39;babel-eslint&#39;, // 解析器类型：espima(默认), babel-eslint, @typescript-eslint/parse parserOptions: { // 解析器配置参数 sourceType: &#39;module&#39; // 代码类型：script(默认), module }, // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style /** * &amp;quot;eslint:recommended&amp;quot;, // 一共有两个：eslint:recommended 、eslint:all * &amp;quot;plugin:react/recommended&amp;quot;, // 扩展是插件类型，也可以直接在 plugins 属性中进行设置 =&amp;gt; extPlugin = `plugin:${pluginName}/${configName}` * &amp;quot;eslint-config-standard&amp;quot;, // 扩展来自 npm 包，官方规定 npm 包的扩展必须以 eslint-config- 开头，使用时可以省略这个头 */ extends: &#39;standard&#39;, // 扩展就是直接使用别人已经写好的 lint 规则，方便快捷 // required to lint *.</description>
    </item>
    
    <item>
      <title>Vue CLI中配置使用Mock数据</title>
      <link>https://luneshao.github.io/2019/vue-cli-mock/</link>
      <pubDate>Tue, 09 Jul 2019 16:27:20 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2019/vue-cli-mock/</guid>
      <description>引言
 鉴于对 Vue CLI 中 webpack 的链式配置一直不熟悉，mock 也没有用过。最近项目需要 mock 数据，所以新建了一个测试项目配置了一下。下面我会介绍配置流程。👇👇👇 (webpack 没理解透彻T_T)
参考文献：
 Vue CLI 文档 webpack-chain 文档 webpack 配置文档 http-proxy-middleware 文档 mockjs-webpack-plugin 文档  文章结构：
+ 配置流程 + Step 1. 安装插件 mockjs-webpack-plugin + Step 2. 配置 webpack 配置项 + Step 3. Mock 数据  配置流程 这里我就默认民那桑已经用 Vue CLI 安装了一个项目。我使用的 Vue CLI 3。
Step 1. 安装插件 mockjs-webpack-plugin  这个插件通过 webpack 插件的方式，快速搭建项目的 mock 服务，用于前后端分离模式下的并行开发。emmm，是公司大佬用的这个，至于为什么我还没敢问 -_-
yarn add mockjs-webpack-plugin --dev 或 cnpm install --save-dev mockjs-webpack-plugin  安装完成后，新建存放 mock 数据的文件夹及文件。文档</description>
    </item>
    
    <item>
      <title>Flutter 安装 CocoaPods</title>
      <link>https://luneshao.github.io/2019/flutter-install/</link>
      <pubDate>Mon, 24 Jun 2019 16:30:36 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2019/flutter-install/</guid>
      <description>引言
 安装 flutter 过程中，卡在 pod setup 这里，总是会报错，找了好多文章也没能解决。最后发现这篇博客=&amp;gt; CocoaPods的安装步骤和遇见的问题 按照里面的步骤，一步一步来就OK了。
安装步骤 // 建议先更新下gem sudo gem update --system // 切换镜像 gem sources --remove https://rubygems.org/ gem sources -a https://gems.ruby-china.com/ gem sources -l // 安装 cocoapods sudo gem install cocoapods 应该会提示下错误 // ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/update_rubygems 试试 gem update -n /usr/local/bin --system // 安装cocoapods （我用的这个） sudo gem install -n /usr/local/bin cocoapods pod repo list // 查看repo 列表 pod repo remove master // 删除master // 添加master库 新版的 CocoaPods 不允许用pod repo add直接添加master库了，现在一般执行完pod repo add master *** 之后又会提示[!</description>
    </item>
    
    <item>
      <title>brew update 无响应</title>
      <link>https://luneshao.github.io/2019/brew-noresponse/</link>
      <pubDate>Mon, 24 Jun 2019 09:24:54 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2019/brew-noresponse/</guid>
      <description> 内容摘自 清华大学开源软件镜像站
替换现有上游 cd &amp;quot;$(brew --repo)&amp;quot; git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git cd &amp;quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&amp;quot; git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git brew update   以上。🐡
 </description>
    </item>
    
    <item>
      <title>windows 添加自定义协议，实现浏览器打开软件</title>
      <link>https://luneshao.github.io/2019/costom-url-protocol/</link>
      <pubDate>Thu, 20 Jun 2019 14:43:42 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2019/costom-url-protocol/</guid>
      <description> 我参考了这篇博客，我使用了原博中 windows 系统的方式，亲测有效。下面贴一下操作步骤：
操作步骤  添加注册表  （1）新建一个 .reg 的文件，填充如下内容。例如我新建一个自定义协议，名称为 lune。请注意，将下面所有的路径（也就是方括号内的内容）中的名称要 全部替换为自定义的名称 ，且名称一定要 全部是小写字母 。
Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\lune] &amp;quot;URL Protocol&amp;quot;=&amp;quot;C:\\WINDOWS\\system32\\calc.exe&amp;quot; @=&amp;quot;LuneProtocol&amp;quot; [HKEY_CLASSES_ROOT\lune\DefaultIcon] @=&amp;quot;C:\\WINDOWS\\system32\\calc.exe,1&amp;quot; [HKEY_CLASSES_ROOT\lune\shell] [HKEY_CLASSES_ROOT\lune\shell\open] [HKEY_CLASSES_ROOT\lune\shell\open\command] @=&amp;quot;\&amp;quot;C:\\WINDOWS\\system32\\calc.exe\&amp;quot; \&amp;quot;%1\&amp;quot;&amp;quot;  （2）双击添加到注册表。
 调用方式
&amp;lt;a href=&amp;quot;lune://123&amp;quot;&amp;gt;click&amp;lt;/a&amp;gt;   注意  [HKEY_CLASSES_ROOT\lune\shell]方括号内的路径（即 lune）要改成自定义的名字。
 自定义的key值，也就是名称，要小写。（都是血与泪&amp;hellip;
  mark 实现浏览器判断本地是否安装程序，并下载与启动 Chrome,IE,360可用
 以上。🐳
 </description>
    </item>
    
    <item>
      <title>如何让自己网站被google收录？</title>
      <link>https://luneshao.github.io/2019/google-console/</link>
      <pubDate>Thu, 13 Jun 2019 10:12:32 +0800</pubDate>
      
      <guid>https://luneshao.github.io/2019/google-console/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;引言&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近两个月一直在鼓捣这个博客，一直也只是用网址访问。最近，尝试在搜索引擎上搜索我博客的url、内容、标题，通通搜不到？？？然后，看了&lt;a href=&#34;https://support.google.com/webmasters/answer/7451184&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;搜索引擎优化 (SEO) 新手指南&lt;/a&gt;。在 google console 上配置了站点地图并进行&lt;a href=&#34;https://support.google.com/webmasters/answer/9012289#url_can_be_on_google_issues&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;网址检查&lt;/a&gt;（查看资源中某个网址的 Google 索引信息）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我的检查结果： &lt;em&gt;此网址未显示在 Google 搜索结果中&lt;/em&gt; 。（此时已经可以在 google 中检索到 url 了。）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;点击查看详情 =&amp;gt; return ( 已抓取 - 尚未编入索引, 状态：已排除。 ) 查看&lt;a href=&#34;https://support.google.com/webmasters/answer/7440203#discovered__unclear_status&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;状态报告指南&lt;/a&gt;去一条一条的排查。我的结果对应的解释：&lt;code&gt;Google 已抓取相应网页，但尚未将其编入索引。日后，该网页可能会被编入索引，也可能不会被编入索引；无论如何，您都无需重新提交该网址以供抓取。&lt;/code&gt; 那就只能静静的等待了。（目前已经搜到了。）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面主要是摘要梳理了搜索引擎优化 (SEO) 新手指南一些相关知识点，帮助理解。&lt;/p&gt;

&lt;p&gt;官方文档先祭一下 &lt;a href=&#34;https://support.google.com/webmasters/answer/7451184&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;搜索引擎优化 (SEO) 新手指南&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-术语&#34;&gt;1.术语&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://support.google.com/webmasters/answer/70897&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Google 搜索的工作方式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Google 按照以下三个基本步骤来生成基于网页的结果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;抓取&lt;/li&gt;
&lt;li&gt;编入索引&lt;/li&gt;

&lt;li&gt;&lt;p&gt;呈现（和排名）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;索引&lt;/strong&gt; - Google 会将所知道的全部网页存储在其“索引”中。每个网页的索引条目都会描述该网页的内容和位置（网址）。编入索引是指当 Google 抓取、读取网页并将其添加到索引的过程。例如：Google 今天已将我网站上的几个网页编入索引。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;抓取&lt;/strong&gt; - 寻找新网页或更新后的网页的过程。Google 会通过跟踪链接、读取站点地图或其他各种方式来发现网址。Google 通过抓取网页来寻找新增网页，然后（在适当的时候）将网页编入索引。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;抓取工具&lt;/strong&gt; - 从网络中抓取（提取）网页并将网页编入索引的自动化软件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Googlebot&lt;/strong&gt; - Google 抓取工具的通用名称。Googlebot 会持续不断地抓取网页。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;SEO&lt;/strong&gt; - 搜索引擎优化：使您的网站更易于搜索引擎抓取和编入索引的过程；也可指从事搜索引擎优化的人员的职位名称，例如：我们刚刚聘请了新的 SEO 来提升我们在网络上的曝光度。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-测试搜索结果&#34;&gt;2.测试搜索结果&lt;/h2&gt;

&lt;p&gt;在 google 中搜索 &lt;code&gt;site:example.com&lt;/code&gt;，尝试是否可以搜索到结果。如果可以搜索到，表明你的网站已经在索引中。搜不到，就继续向下看吧:)&lt;/p&gt;

&lt;h2 id=&#34;3-如何让-google-收录您的内容&#34;&gt;3.如何让 Google 收录您的内容&lt;/h2&gt;

&lt;p&gt;最好的办法是提交&lt;a href=&#34;https://support.google.com/webmasters/answer/156184?hl=zh-Hans&amp;amp;ref_topic=4581190&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;站点地图&lt;/a&gt; 。站点地图是网站上的一种文件，可告知搜索引擎网站上新增了网页或有更新的网页。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这里，我的博客本来是在 google 搜索不到的，hugo 会在 public 文件夹自动生成站点地图。（如果没有使用hugo，&lt;a href=&#34;https://support.google.com/webmasters/answer/183668?hl=zh-Hans&amp;amp;ref_topic=4581190&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;文章&lt;/a&gt;中也提供了一些在线生成站点地图的网址和工具，可以自行生成哟～）此时，需要我们做的就是在 Search Console 工具中，自行配置站点地图的 url，或者将其添加到您的 robots.txt 文件中。然后，在 google 输入 site:luneshao.github.io 就可以搜索到了。一小步进步啊！&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-告诉-google-不应抓取哪些页面&#34;&gt;4.告诉 Google 不应抓取哪些页面&lt;/h2&gt;

&lt;p&gt;若为非敏感信息，则可以使用 robots.txt 阻止不必要的抓取。&lt;/p&gt;

&lt;h2 id=&#34;5-帮助-google-和用户-了解您的内容&#34;&gt;5.帮助 Google（和用户）了解您的内容&lt;/h2&gt;

&lt;p&gt;诸位可以使用这个&lt;a href=&#34;http://analyzer.metatags.org/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;免费网站分析工具&lt;/a&gt;，分析一下自己的网站 seo 方面是否存在不足。&lt;/p&gt;

&lt;h3 id=&#34;5-1-创建唯一且准确的网页标题&#34;&gt;5.1 创建唯一且准确的网页标题&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; 标记可告诉用户和搜索引擎特定网页的主题是什么。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;title&amp;gt;unique title&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-2-创建恰当的标题和摘要以在搜索结果中显示&#34;&gt;5.2 创建恰当的标题和摘要以在搜索结果中显示&lt;/h3&gt;

&lt;p&gt;如果您的文档会显示在搜索结果页中，则 title 标记的内容可能会显示在相应结果的第一行&lt;/p&gt;

&lt;h3 id=&#34;5-3-使用-description-元标记&#34;&gt;5.3 使用“description”元标记&lt;/h3&gt;

&lt;p&gt;网页的说明元标记可让 Google 和其他搜索引擎了解该网页的大致内容。网页的标题可以是几个词或一个短语，而网页的说明元标记则可以是一两个句子或是一小段话。&lt;/p&gt;

&lt;h4 id=&#34;说明元标记有哪些好处&#34;&gt;说明元标记有哪些好处？&lt;/h4&gt;

&lt;p&gt;说明元标记很重要，因为 Google 可能会将其用作您网页的摘要。为每个网页添加说明元标记从来都是非常好的做法，以防 Google 找不到要在摘要中使用的恰当文字。&lt;/p&gt;

&lt;h3 id=&#34;5-4-使用标题标记强调重要文字&#34;&gt;5.4 使用标题标记强调重要文字&lt;/h3&gt;

&lt;p&gt;按顺序使用多种大小的标题可为您的内容创建层次结构，便于用户浏览文档。&lt;/p&gt;

&lt;h3 id=&#34;5-5-添加结构化数据标记&#34;&gt;5.5 添加结构化数据标记&lt;/h3&gt;

&lt;p&gt;结构化数据21是可添加到网站页面中的代码，用于向搜索引擎描述内容，以便搜索引擎更好地了解网页上的信息。搜索引擎可以利用这类信息在搜索结果中以有用的（且吸引用户的）方式显示您的内容。这也有助于您吸引到适合您业务的客户。&lt;/p&gt;

&lt;p&gt;例如，如果您有一个网店并且标记了一个单独的产品页面，这将帮助我们了解该页面主要显示自行车、自行车价格以及客户评价。我们可能会在相关查询的搜索结果的摘要中显示这些信息。我们将其称之为“富媒体搜索结果”。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;富媒体搜索结果：Google 搜索结果中的增强型结果，具有额外的视觉效果或互动功能。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>小程序云开发</title>
      <link>https://luneshao.github.io/2019/miniprogram/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/miniprogram/</guid>
      <description>引言
 最近和一个小姐姐在互相监督学习，所以想找一个工具打卡使用。没有找到那种到手即用的，就自己做一个了。结果，审核未通过。为啥呢，因为没好好看限制内容，个人的账号可以做的东西很少，文档敬上。
不过过程中遇到的一些问题，打算记录下来。希望能帮助看到这篇文章的你避免一些坑吧。
文章目录：
 页面开发 组件开发 字体图标 云函数  —————————— 一个渣渣前端的独白
1.页面开发  1.使用 this.setData({}) 赋值。
 2.页面向函数传参使用 dataset。请戳官方文档
&amp;lt;!-- page.html --&amp;gt; &amp;lt;view data-index=&#39;{{index}}&#39; bindtap=&amp;quot;handelItemDel&amp;quot;&amp;gt; {{ item }} &amp;lt;/view&amp;gt;  // page.js handelItemDel(e) { let { selArr } = this.data const index = e.target.dataset.index selArr.splice(index, 1) this.setData({ selArr: selArr }) },  3.在 app.json 中，page 项数组的第一个页面是小程序的主页（即第一个跳转到的页面）。
  2.组件开发 在 miniprogram 的目录下新建一个 components 文件夹，在文件夹内创建 组件。在页面中引用时，需要在页面的 json 文件中引入组件。key 值就是在页面中引入的标签名。</description>
    </item>
    
    <item>
      <title>强大的css filter属性及色彩名词（附 opacity 属性的兼容写法）</title>
      <link>https://luneshao.github.io/2019/css-filter/</link>
      <pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/css-filter/</guid>
      <description>引言
 最近公司需要找一个管理项目的工具，然后被推荐了 coding.net，我就看了一下官网的功能介绍。看到合作伙伴那里，hover 之后，图片变了颜色。然后，职业病就犯了，就看了一下人家是怎么实现的。
讲道理，我找了半天是怎么换的颜色。filter 这个属性之前看到是用来兼容 ie 的 opacity 属性的，我也一直没有用过，就以为它就是透明度的属性，我就没勾掉试一试。。。有点愚蠢。我就以为是换了图片的 URL，结果图片的 URL 并没有变化。我查看了图片，它本来的颜色就是彩色的。然后猜测，难道是利用 css 改变了图片的颜色？？？我就挨个属性勾了勾，果然是 filter 的原因。。
默认的 css 属性中，有这么一句 filter: grayscale(100%); ，这就是让图片变灰的属性。然后，就滚去 MDN 了。首屏就是几个例子，我又震惊了！这个属性可以做这么多事！！上一次震惊是在发现了 object-fit 属性，竟然可以改变图片内容的尺寸！
（文档真的要认真看，仔细看，可能某个小括号里边就提供了一种简便方法或者功能介绍。）
本篇主要是摘要了 MDN 的 filter 属性、取值及示例图以及关于色相、饱和度、灰度的概念。末尾附上了一份 opacity 的兼容性写法。
定义 filter：滤镜。
filter CSS属性将模糊或颜色偏移等 图形效果应用于元素 。滤镜通常用于调整图像，背景和边框的渲染。 CSS标准里包含了一些已实现预定义效果的函数。你也可以参考一个SVG滤镜，通过一个URL链接到SVG滤镜元素(SVG filter element)。
语法 共分为四类。具体的我就不搬运了，下面具体介绍。形式语法
/* 自定义的 SVG 滤镜 */ .filter: url(&amp;quot;filters.svg#filter-id&amp;quot;) /* 滤镜函数 */ blur、brightness、contrast、drop-shadow、grayscale、hue-rotate invert、opacity、saturate、sepia .filter: blur(5px); /* 混合滤镜 */ filter: contrast(175%) brightness(3%); /* Global values */ filter: inherit; filter: initial; filter: unset;  函数 url: URL函数接受一个XML文件，该文件设置了一个 SVG滤镜 ，且可以包含一个锚点来指定一个具体的滤镜元素.</description>
    </item>
    
    <item>
      <title>window.requestAnimationFrame方法</title>
      <link>https://luneshao.github.io/2019/window-requestanimationframe/</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/window-requestanimationframe/</guid>
      <description>原文链接伯乐 MDN
概念 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。
个人理解：raf 这个函数可以用来做动画，它需要一个参数，参数的形式是一个回调函数，在回调函数里可以写需要执行的动画。
这个回调函数会默认接收一个参数，即执行回调函数时的时间戳，回调函数，会在每次浏览器在下次重绘前执行回调函数更新动画，个人认为这样来保证动画的帧率和稳定性。大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次，相当于每帧的执行时间为 16.67ms。
特性  参数中的回调函数执行次数通常是每秒60次，速度大约为 16.67ms 每帧。
 当requestAnimationFrame()运行在后台标签页或者隐藏的&amp;lt;iframe&amp;gt; 里时，requestAnimationFrame() 会被暂停调用。对比 setTimeout ，离开页面依旧会计时，raf 更加节省性能。
 DOMHighResTimeStamp指示由 RequestAnimationFrame() 排队的回调开始触发的时间。
 它返回一个整数，表示定时器的编号，这个值可以传递给 cancelAnimationFrame 用于取消这个函数的执行。
  使用方法 window.requestAnimationFrame(callback) function callback (timeStamp) { // 默认接收参数 timeStamp，表示开始执行回调函数的时刻 // 若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame() window.requestAnimationFrame(callback) }  避免一帧多次调用 let ifCurFra = false // 当前帧是否执行 function cb (timeStamp) { if (ifCurFra) return ifCurFra = true window.requestAnimationFrame(timeStamp =&amp;gt; { ifCurFra = false }) } window.</description>
    </item>
    
    <item>
      <title>CSS Tranform 的 Matrix函数</title>
      <link>https://luneshao.github.io/2019/css-matrix/</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/css-matrix/</guid>
      <description>插播一句：translate 的百分比是相对于自身的宽高计算的。
插播2：计算角度值 eg：已知 sin(a) = 1，求 a？。 a = Math.asin(1) * 180 / Math.PI
 引言
 这也是关于优化 js 代码衍生出来的内容，过程是这样的。
 文章里说 Array.from 代替 Array.prototype.slice.call(arrayLike)，😳Array.prototype.slice.call(arrayLike) 是不是截取数组的嘛，查了一下文档 MDN ，原来将这个方法绑定到类数组对象/集合上，就可以转化为一个数组。过程中，看到了这篇博客，大佬是真的🐂🍺，里边就写到了计算用window.getComputedStyle(dom, 伪类) 获取值，本来我是忽略过去的，但是，好奇心让我测试了一下。。得到了一个这个东西。  这是啥？我不认识啊？？还是乖乖的学一下吧。
translate 值的计算 于是学习了 张鑫旭前辈的文章，这是一个矩阵，是transform变换的基础。我们可以根据这个矩阵里面的值推算出，transform 属性的值。
其格式为：Matrix(a, b, c, d, e, f) 具体的介绍请直接看前辈文章的第五节。
借前辈图，translate &amp;amp; scale 的转换公式如下。 ：
 x, y ：表示转换元素的所有坐标（变量）矩阵偏移元素的中心点。 ax+cy+e ：变换后的x坐标 bx+dy+f ：变换后的y坐标  scale 值的计算 matrix(s, 0, 0, s, 0, 0); s 即为 scale 的值。</description>
    </item>
    
    <item>
      <title>=8 一些不常用的获取元素属性的操作</title>
      <link>https://luneshao.github.io/2019/element-expland/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/element-expland/</guid>
      <description>1. 获取元素的css  1.1 window.getComputedStyle()  返回另一个包含所有 css 属性的对象，该对象应用了样式表并解析了基础计算（只读）。
window.getComputedStyle().getPropertyValue(&#39;font&#39;) // 获取属性 font 值  MDN 张鑫旭前辈的文章
css 安全(blog)
2.获取元素的大小及其相对于视口的位置  2.1 Element.getComputedStyle()  MDN
返回元素的大小及其相对于视口的位置。
如果你需要获得相对于整个网页左上角定位的属性值，那么只要给top、left属性值加上当前的滚动位置
（通过window.scrollX和window.scrollY），这样就可以获取与当前的滚动位置无关的值。
3.返回当前document对象所关联的window对象  3.1 document.defaultView  MDN
该属性返回当前 document 对象所关联的 window 对象，如果没有，会返回 null。
在许多在线的演示代码中，getComputedStyle是通过 document.defaultView 对象来调用的。大部分情况下，这是不需要的，因为可以直接通过window对象调用。但有一种情况，你必需要使用 defaultView, 那是在firefox3.6上访问子框架内的样式。</description>
    </item>
    
    <item>
      <title>js 代码美化 (持续更新)</title>
      <link>https://luneshao.github.io/2019/js-beauty/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/js-beauty/</guid>
      <description>github完整文章连接
Objects  1.1 将简写属性，放在对象定义的开始部分。
// bad const obj = { key1: 2, key2, key3: 2, } // good const obj = { key2, key4, key1: 2, key3: 2, }  1.2 不要直接调用 Object.prototype，例如 hasOwnProperty， propertyIsEnumerable，
  因为这些名字没有被 Javascript 保留，如果被重新定义就会被覆盖。所以，最好是在原型链上调用。
MDN相关连接
// bad const a = obj.hasOwnProperty(&#39;name&#39;) // good const a = Object.prototype.hasOwnProperty.call(obj, &#39;name&#39;) // best // has.js const has = Object.prototype.hasOwnProperty // use.js import has from &#39;./has.js&#39; const a = has.</description>
    </item>
    
    <item>
      <title>CSS 的 clip 属性</title>
      <link>https://luneshao.github.io/2019/css-clip/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/css-clip/</guid>
      <description>参考文献：MDN&amp;emsp; 张鑫旭前辈的文章
介绍 定义 clip 属性剪裁元素，属性仅应用于绝对定位元素，例如 position: absolute 或 position: fixed。
属性值  auto：不剪裁。
 &amp;lt;shape&amp;gt;：截取的形状，值的表示方式 rect(&amp;lt;top&amp;gt;, &amp;lt;right&amp;gt;, &amp;lt;bottom&amp;gt;, &amp;lt;left&amp;gt;) 或 rect(&amp;lt;top&amp;gt; &amp;lt;right&amp;gt; &amp;lt;bottom&amp;gt; &amp;lt;left&amp;gt;)。
  top &amp;amp; bottom 设置的是距离元素上边距的距离。left &amp;amp; right 设置的是距离元素左边距的距离。
左侧使用了clip属性，左右容器和图片的尺寸都是200 * 200。 top、right、bottom、left 的值可以是 数值 或 auto 。
tips：auto表示 If any side&amp;rsquo;s value is auto, the element is clipped to that side&amp;rsquo;s inside border edge. （文档） 截取到元素该边的内边界。
 inherit：从父元素继承 clip 属性的值，不兼容 IE6。   实例</description>
    </item>
    
    <item>
      <title>js Date 对象</title>
      <link>https://luneshao.github.io/2019/js-date/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/js-date/</guid>
      <description>参考文献：MDN
常用方法 语法 new Date()： 返回一个 Date 对象
new Date(value)：
new Date(dateString)：
new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])：
Date() : 以函数形式直接调用 Date()，返回一个字符串
new Date() 参数 (value)： 一个整数值，表示自1970年1月1日00:00:00 UTC（the Unix epoch）以来的毫秒数。
(dateString)： 表示日期的字符串值。
(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]])：
year：表示年份的整数值。
monthIndex：表示月份的整数值，从 0（1月）到 11（12月）。
day：表示一个月中的第几天的整数值，从1开始。
hours：小时数的整数值 (24小时制)。
minutes：时间中分钟部分的整数值。
seconds：时间中的秒部分的整数值。
milliseconds：时间的毫秒部分的整数值。
方法 Date.now()： 返回自 1970-1-1 00:00:00 UTC（世界标准时间）至今所经过的毫秒数。
Date.parse()： 解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。</description>
    </item>
    
    <item>
      <title>hugo 介绍及使用</title>
      <link>https://luneshao.github.io/2019/hugo-intro/</link>
      <pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/hugo-intro/</guid>
      <description>引言 本篇文章简单介绍了 Hugo 的目录结构和博客内一些个性化内容(评论、音乐、google analyze)的实现。
使用 Hugo 生成博客还请大家移步至 Hugo中文文档，我看着挺清晰的，比英文文档好看啊&amp;hellip;
我目前使用的是 hugo-lamp 这个主题，绿绿的多好看😏。
1.Hugo 目录结构 原文连接
├── archetypes // 储存.md的模板文件，新建一个 .md 文件时，就会按此模版创建 ├── content // 储存网站的所有内容，写的文章存放在这里 ├── data // 储存数据文件供模板调用（目前没有用到过） ├── layouts // 储存.html模板（也莫的用） ├── static // 储存图片,css,js等静态文件，该目录下的文件会直接拷贝到/public ├── themes // 储存主题 └── config.toml // 配置文件  图片的引用 Hugo 的图片可以直接放在其 static/img 目录里面，其路径就是 /img/image_name.png。
[2019-06-12日更新]
众所周知，安装主题是在 themes 文件夹下，根据不同的主题，都会有相应的文档介绍，告诉我们怎么去写配置文件。此主题的文档在 /docs/guide.md，根据这个文档可以把自己的名字、签名、地址一系列安排的妥妥当当。
看到大神们有人在博客里放了评论、音乐，还使用了图床，就也想鼓捣。还有，我的博客没有被搜索引擎收录，我还得搞一搞。目前我已经添加了评论、音乐和 google analyze的功能，记录一下过程。
2.hugo 添加评论功能 [20190613 更新，我已经换掉了。换成 Valine 了。]
我使用的是 disqus。 参考文章，真的是极好。</description>
    </item>
    
    <item>
      <title>USB 接口类型</title>
      <link>https://luneshao.github.io/2019/usb-types/</link>
      <pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/usb-types/</guid>
      <description>USB: 通用串行总线（英语：Universal Serial Bus，缩写：USB）是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范，
文档地址
   USB类型 对应图片     USB A-Type    USB B-Type    USB C-Type    Micro-USB A    Micro-USB B    USB Mini-b(5-pin)    USB Mini-b(4-pin)    USB 3.0 A-Type    USB 3.0 B-Type    USB 3.0 Micro B     </description>
    </item>
    
    <item>
      <title>=8 浏览器易混淆名词整理</title>
      <link>https://luneshao.github.io/2019/browser-num/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/browser-num/</guid>
      <description> 1.JS 的 window.location 对象 包含有关文档及当前位置的信息。
MDN文档地址
 location.origin: 包含页面来源的域名的标准形式，当前页面的域名 + 端口。 eg: https://www.baidu.com
 location.host: 当前页面的域名，可能最后带有一个“：”和端口。 eg: www.baidu.com
 location.hostname: 当前页面的域名。 eg: www.baidu.com
 location.protocol: 当前页面的协议。 eg: https
 location.assign(): 加载给定 URL 的内容到这个 Location对象所关联的对象上。
 location.reload(params): 重新加载当前页。params: t/f =&amp;gt; 服务器请求资源/缓存。
 location.replace(): 用给定的URL替换当前的资源，不会被保存历史。
  2.ajax 请求头中的属性 MDN文档地址
 Host: 服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的TCP端口号。 相关文章一个IP可以部署众多网站，分别解析不同的域名，host 指示访问哪个虚拟主机。
 Origin: 请求来自于哪个站点，该字段仅指示服务器名称，并不包含任何路径信息。
 Referer: 当前请求页面的来源页面的地址。B -&amp;gt; A, Referer: B.URL
  </description>
    </item>
    
    <item>
      <title>markdown 常用语法</title>
      <link>https://luneshao.github.io/2019/markdown/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/markdown/</guid>
      <description>列表 // 无序列表 * txt txt txt + txt txt txt - txt txt txt // 有序列表 1. txt txt txt 2. txt txt txt  引用 &amp;gt; txt txt txt  粗体 和 斜体 // 粗体 **txt** / __txt__ // 斜体 *txt* / _txt_  表格 | thead | thead | thead | | :---- | :---: | ----: | | 左对齐 | 居中 | 右对齐 |  分隔线 *** / - - - / * * *  图片 !</description>
    </item>
    
    <item>
      <title>前端属性兼容性整理</title>
      <link>https://luneshao.github.io/2019/comp/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/comp/</guid>
      <description>1.document 相关 1.1 addEventListen
兼容写法：
function addEvt(eTarget, eType, eHandle) { if (eTarget.addEventListen) { eTarget.addEventListen(eType, eHandle) } else { // ie 浏览器 if (eTarget.attachEvent) { eType = &#39;on&#39; + eType eTarget.attachEvent(eType, eHandle) } else { eventTarget[&#39;on&#39; + eventType] = eventHandler } } }  1.2 scrollTop()
兼容写法：
// 因为 0 || undefine =&amp;gt; undefined const st = document.pageYOffset.scrollTop || document.documentElement.scrollTop || document.body.scrollTop || 0  // ie6/7/8 1. 没有 doctype 声明的页面： const st = document.</description>
    </item>
    
    <item>
      <title>Mac 的快捷键</title>
      <link>https://luneshao.github.io/2019/mac-keyboard/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/mac-keyboard/</guid>
      <description>在知乎上截取部分自己会用到的一部分。
 按键符号
  ⌘ (command) ⌥ (option) ⇧ (shift) ⌃ (control) ⌫ (delete)   常用的快捷键
  快速调用 emoji 表情：⌘（command）+ ⌃（control）+ 空格键；   浏览器中将网页加入个人收藏：⌘（command）+ D；遇到喜欢的网页内容只需按下此快捷键即可加入收藏夹；
 截屏 + 录屏：⌘ （command）+ ⌥（option） + R 即可调出
 光标移到地址框：Command + L
  附：CheatSheet 下载地址
 以上。谢谢各位大佬的分享🤩
 </description>
    </item>
    
    <item>
      <title>蔬菜水煮建议时间</title>
      <link>https://luneshao.github.io/2019/vegetable/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/vegetable/</guid>
      <description>要注意水煮时间要根据蔬菜的切块大小以及想追求的柔软程度，下面的时间仅是指导 (单位为分钟)：
 洋蓟(整个): 25-40
 洋蓟(芯儿): 10-15
 胡萝卜(整个): 15-20
 胡萝卜(整个): 5-10
 菜花 (整个): 10-15
 菜花: (掰成朵): 5-8
 玉米: 4-7
 茄子 (整个): 10-15
 茄子 (切块): 5-10
 蘑菇: 3-4
 洋葱 (整个): 20-30
 洋葱 (珍珠): 10-20
 欧防风: 5-10
 青椒: 4-5
 南瓜 (切片): 5-10
 西红柿: 1-3
 芜菁 (整个): 15-20
 芜菁 (小块): 5-8
 菜花: 4-6
 西兰花(掰成朵): 4-6</description>
    </item>
    
    <item>
      <title>每天一集TED 20190415</title>
      <link>https://luneshao.github.io/2019/0415/</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/0415/</guid>
      <description> 是什么让你睡不着觉？ 防止失眠的方法  治疗失眠最好的方法之一是，管理好会造成过度警觉的压力。  确保你的卧室十分舒爽，你的床只是用来睡觉，如果睡不着就去看会书、
冥想或者写日记。
 调节你的新陈代谢，做法是维持一贯的睡眠和起床作息，来协助调整你的生物钟。因为这个生物钟对光很敏感，所以夜间避免亮光。
 有些医生也会开一些药物，但是药物很容易上瘾，导致病情恶化。
 还有一些人是基因问题。（DSPD）
  以上。
欧亚斯密。
 (&amp;gt;^ω^&amp;lt;)
 </description>
    </item>
    
    <item>
      <title>初次见面</title>
      <link>https://luneshao.github.io/2019/my-first-post/</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/2019/my-first-post/</guid>
      <description>介绍 初次见面，请多多关照。 &amp;ndash;来自萌新的问候。（≧∇≦）
这样规定一下：
 标题带有 =3 的就是我有未看完的内容的 （ 怕不是都要带着了 23333
 标题带有 =8 的就是持续更新的文章
   （≧∇≦）
 来自萌新的问候 （≧∇≦）</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luneshao.github.io/1/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/1/http/</guid>
      <description>+++ title = &amp;ldquo;httt 协议与 TCP/IP 协议&amp;rdquo; description = &amp;ldquo;http 协议和 TCP/IP 协议的理解，以及一些简写的释义。&amp;rdquo; tags = [&amp;lsquo;http&amp;rsquo;, &amp;lsquo;前端&amp;rsquo;] date = &amp;ldquo;2019-09-03&amp;rdquo; location = &amp;ldquo;JiNan, CN&amp;rdquo; type = &amp;ldquo;post&amp;rdquo; draft=&amp;ldquo;true&amp;rdquo; +++ 参考微信公众号文章，记录一些知识点，原文请点击 👉🏻微信公众号原文
名词缩写释义 OSI 参考模型：OSI 参考模型是一个尝试让全世界计算机互联为网络的概念性框架，为定制标准提供参考的概念性框架。
OSI 参考模型中将计算机网络体系结构划分为 7 层，从下至上依次是：
 物理层：光纤和网卡等，负责通信设备和网络媒体之间的互通 数据链路层：以太网，用来加强物理层功能 网络层：IP 协议和 ICMP 协议等，负责数据的路由的选择与数据转寄 传输层：TCP 协议和 UDP 协议等，承上启下，控制连接，控制流量 会话层：建立和维护会话关系 表达层：把数据转换为接受者系统可兼容的格式 应用层：HTTP、FTP、SMTP 和 SSH 等，粗犷的理解为程序员层  TCP/IP 参考模型：TCP/IP 协议代表一整个网络传输协议家族，而不仅仅是 TCP 协议和 IP 协议，TCP 协议和 IP 协议是该协议家族中最早通过的最核心的两个协议标准，因此该协议家族被称作 TCP/IP 协议族，也就是我们通常所说的 TCP/IP 协议。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://luneshao.github.io/1/js-expland/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://luneshao.github.io/1/js-expland/</guid>
      <description>+++ title = &amp;ldquo;=8 js 拓展&amp;rdquo; description = &amp;ldquo;js 拓展&amp;rdquo; tags = [&amp;ldquo;Javascrip&amp;rdquo;, &amp;ldquo;前端&amp;rdquo;] date = &amp;ldquo;2019-05-27&amp;rdquo; location = &amp;ldquo;JiNan, CN&amp;rdquo; type = &amp;ldquo;post&amp;rdquo; keywords = &amp;ldquo;javascript,Date,前端&amp;rdquo; +++
1.Array 1.1 将类数组转化为数组  Array.prototype.slice.call() 方法：  MDN slice相关
slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。你只需将该方法绑定到这个对象上。
Array.slice(start, end) 方法用来截取数组 start 到 end （不包含 end）值，并返回一个新数组。
function list () { return Array.property.slice.call(arguments) } list(1, 2, 3)  除此以外可以使用 [].splice.call(arguments) 代替，也可以使用 bind 来简化过程。
const unboundSlice = Array.property.slice const slice = Function.</description>
    </item>
    
  </channel>
</rss>